<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="1.8 Computational complexity | Lectures on Quantum Information Science" />
<meta property="og:type" content="book" />


<meta property="og:description" content="The online version of an introductory series of lectures on quantum computing." />


<meta name="author" content="Artur Ekert" />

<meta name="date" content="2020-11-15" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<meta name="description" content="The online version of an introductory series of lectures on quantum computing.">

<title>1.8 Computational complexity | Lectures on Quantum Information Science</title>

<script src="libs/header-attrs-2.5/header-attrs.js"></script>
<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-background.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.0/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0/anchor-sections.js"></script>





</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#overview">Overview</a></li>
<li><a href="1-quantum-interference.html#quantum-interference"><span class="toc-section-number">1</span> Quantum interference</a>
<ul>
<li><a href="1-1-two-basic-rules.html#two-basic-rules"><span class="toc-section-number">1.1</span> Two basic rules</a></li>
<li><a href="1-2-quantum-interference-the-failure-of-probability-theory.html#quantum-interference-the-failure-of-probability-theory"><span class="toc-section-number">1.2</span> Quantum interference (the failure of probability theory)</a>
<ul>
<li><a href="1-2-quantum-interference-the-failure-of-probability-theory.html#the-double-slit-experiment"><span class="toc-section-number">1.2.1</span> The double slit experiment</a></li>
</ul></li>
<li><a href="1-3-superpositions.html#superpositions"><span class="toc-section-number">1.3</span> Superpositions</a></li>
<li><a href="1-4-interferometers.html#interferometers"><span class="toc-section-number">1.4</span> Interferometers</a></li>
<li><a href="1-5-qubits-gates-and-circuits.html#qubits-gates-and-circuits"><span class="toc-section-number">1.5</span> Qubits, gates, and circuits</a></li>
<li><a href="1-6-quantum-decoherence.html#quantum-decoherence"><span class="toc-section-number">1.6</span> Quantum decoherence</a></li>
<li><a href="1-7-computation-deterministic-probabilistic-and-quantum.html#computation-deterministic-probabilistic-and-quantum"><span class="toc-section-number">1.7</span> Computation: deterministic, probabilistic, and quantum</a></li>
<li><a href="1-8-computational-complexity.html#computational-complexity"><span class="toc-section-number">1.8</span> Computational complexity</a></li>
<li><a href="1-9-outlook.html#outlook"><span class="toc-section-number">1.9</span> Outlook</a></li>
<li><a href="1-10-notes-and-exercises.html#notes-and-exercises"><span class="toc-section-number">1.10</span> Notes and Exercises</a></li>
<li><a href="1-11-supplement-physics-against-logic-via-beamsplitters.html#supplement-physics-against-logic-via-beamsplitters"><span class="toc-section-number">1.11</span> Supplement: Physics against logic, via beamsplitters</a></li>
<li><a href="1-12-supplement-quantum-interference-revisited-still-about-beamsplitters.html#supplement-quantum-interference-revisited-still-about-beamsplitters"><span class="toc-section-number">1.12</span> Supplement: Quantum interference revisited (still about beamsplitters)</a></li>
</ul></li>
<li><a href="2-qubits.html#qubits"><span class="toc-section-number">2</span> Qubits</a></li>
<li><a href="3-measurements.html#measurements"><span class="toc-section-number">3</span> Measurements</a></li>
<li><a href="4-quantum-entanglement.html#quantum-entanglement"><span class="toc-section-number">4</span> Quantum entanglement</a></li>
<li><a href="5-quantum-algorithms.html#quantum-algorithms"><span class="toc-section-number">5</span> Quantum algorithms</a></li>
<li><a href="6-bells-theorem.html#bells-theorem"><span class="toc-section-number">6</span> Bell’s theorem</a>
<ul>
<li><a href="6-1-quantum-correlations.html#quantum-correlations"><span class="toc-section-number">6.1</span> Quantum correlations</a></li>
<li><a href="6-2-hidden-variables.html#hidden-variables"><span class="toc-section-number">6.2</span> Hidden variables</a></li>
<li><a href="6-3-chsh-inequality.html#chsh-inequality"><span class="toc-section-number">6.3</span> CHSH inequality</a></li>
<li><a href="6-4-quantum-correlations-revisited.html#quantum-correlations-revisited"><span class="toc-section-number">6.4</span> Quantum correlations revisited</a></li>
<li><a href="6-5-tsirelsons-inequality.html#tsirelsons-inequality"><span class="toc-section-number">6.5</span> Tsirelson’s inequality</a></li>
</ul></li>
<li><a href="7-decoherence-and-elements-of-quantum-error-correction.html#decoherence-and-elements-of-quantum-error-correction"><span class="toc-section-number">7</span> Decoherence, and elements of quantum error correction</a></li>
<li><a href="8-density-matrices.html#density-matrices"><span class="toc-section-number">8</span> Density matrices</a></li>
<li><a href="9-quantum-channels-or-cp-maps.html#quantum-channels-or-cp-maps"><span class="toc-section-number">9</span> Quantum channels (or CP maps)</a></li>
<li><a href="10-quantum-error-correction-and-fault-tolerance.html#quantum-error-correction-and-fault-tolerance"><span class="toc-section-number">10</span> Quantum error correction and fault tolerance</a></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="computational-complexity" class="section level2" number="1.8">
<h2><span class="header-section-number">1.8</span> Computational complexity</h2>
<p>Is there a compelling reason why we should care about quantum computation?
It may sound like an extravagant way to compute something that can be computed anyway.
Indeed, your standard laptop, given enough time and memory, can simulate pretty much any physical process.
In principle, it can also simulate any quantum interference and compute everything that quantum computers can compute.
The snag is, this simulation, in general, is very inefficient.
And efficiency does matter, especially if you have to wait more than the age of the Universe for your laptop to stop and deliver an answer!<label for="tufte-sn-6" class="margin-toggle sidenote-number">6</label><input type="checkbox" id="tufte-sn-6" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">6</span> The age of the Universe is currently estimated at 13.772 billion years.</span></p>
<p>In order to solve a particular problem, computers (classical or quantum) follow a precise set of instructions — an <strong>algorithm</strong>.
Computer scientists quantify the efficiency of an algorithm according to how rapidly its running time, or the use of memory, increases when it is given ever larger inputs to work on.
An algorithm is said to be  if the number of elementary operations taken to execute it increases no faster than a polynomial function of the size of the input.<label for="tufte-sn-7" class="margin-toggle sidenote-number">7</label><input type="checkbox" id="tufte-sn-7" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">7</span> Note that the technological progress alone, such as increasing the speed of classical computers, will never turn an inefficient algorithm (exponential scaling) into an efficient one (polynomial scaling). Why?</span>
We take the input size to be the total number of binary digits (bits) needed to specify the input.
For example, using the algorithm taught in elementary school, one can multiply two <span class="math inline">\(n\)</span> digit numbers in a time that grows like the number of digits squared, <span class="math inline">\(n^2\)</span>.
In contrast, the fastest-known method for the reverse operation — factoring an <span class="math inline">\(n\)</span>-digit integer into prime numbers — takes a time that grows exponentially, roughly as <span class="math inline">\(2^n\)</span>.
That is considered inefficient.</p>
<p>The class of problems that can be solved by a deterministic computer in polynomial time is represented by the capital letter , for  time.
The class of problems that can be solved in polynomial time by a probabilistic computer is called , for  time.
It is clear that  contains , since a deterministic computation is a special case of a probabilistic computation in which we never consult the source of randomness.
When we run a probabilistic (a.k.a. randomised) computation many times on the same input, we will not get the same answer every time, but the computation is useful if the probability of getting the right answer is high enough.
Finally, the complexity class , for , is the class of problems that can be solved in polynomial time by a quantum computer.
Since a quantum computer can easily generate random bits and simulate a probabilistic classical computer,  certainly contains the class .
Here we are interested in problems that are in  but not known to be in .
The most popular example of such a problem is factoring.
A quantum algorithm, discovered by Peter Shor in 1994, can factor <span class="math inline">\(n\)</span>-digit numbers in a number of steps that grows only as <span class="math inline">\(n^2\)</span>, as opposed to the <span class="math inline">\(2^n\)</span> that we have classically.<label for="tufte-sn-8" class="margin-toggle sidenote-number">8</label><input type="checkbox" id="tufte-sn-8" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">8</span> It must be stressed that not all quantum algorithms are so efficient, in fact many are no faster than their classical counterparts. Which particular problems will lend themselves to quantum speed-ups is an open question.</span>
Since the intractability of factorisation underpins the security of many methods of encryption, Shor’s algorithm was soon hailed as the first `killer application’ for quantum computation: something very useful that only a quantum computer could do.
Since then, the hunt has been on for interesting things for quantum computers to do, and at the same time, for the scientific and technological advances that could allow us to build quantum computers.</p>
</div>
<p style="text-align: center;">
<a href="1-7-computation-deterministic-probabilistic-and-quantum.html"><button class="btn btn-default">Previous</button></a>
<a href="1-9-outlook.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
