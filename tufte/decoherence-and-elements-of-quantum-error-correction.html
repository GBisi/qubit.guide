<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Chapter 8 Decoherence, and elements of quantum error correction | Lectures on Quantum Information Science" />
<meta property="og:type" content="book" />


<meta property="og:description" content="The online book version of an introductory series of lectures on quantum computing." />


<meta name="author" content="Artur Ekert, ed. Tim Hosgood" />


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<meta name="description" content="The online book version of an introductory series of lectures on quantum computing.">

<title>Chapter 8 Decoherence, and elements of quantum error correction | Lectures on Quantum Information Science</title>

<script src="libs/header-attrs-2.5.3/header-attrs.js"></script>
<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-background.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>




<link rel="stylesheet" href="tufte-custom.css" type="text/css" />
<link rel="stylesheet" href="global.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#introduction">Introduction</a></li>
<li><a href="quantum-interference-and-things-to-come.html#quantum-interference-and-things-to-come"><span class="toc-section-number">1</span> Quantum interference, and things to come</a></li>
<li><a href="qubits.html#qubits"><span class="toc-section-number">2</span> Qubits</a></li>
<li><a href="linking-pauli-matrices-and-the-bloch-sphere.html#linking-pauli-matrices-and-the-bloch-sphere"><span class="toc-section-number">3</span> Linking Pauli matrices and the Bloch sphere</a></li>
<li><a href="measurements.html#measurements"><span class="toc-section-number">4</span> Measurements</a></li>
<li><a href="quantum-entanglement.html#quantum-entanglement"><span class="toc-section-number">5</span> Quantum entanglement</a></li>
<li><a href="quantum-algorithms.html#quantum-algorithms"><span class="toc-section-number">6</span> Quantum algorithms</a></li>
<li><a href="bells-theorem.html#bells-theorem"><span class="toc-section-number">7</span> Bell’s theorem</a></li>
<li><a href="decoherence-and-elements-of-quantum-error-correction.html#decoherence-and-elements-of-quantum-error-correction"><span class="toc-section-number">8</span> Decoherence, and elements of quantum error correction</a></li>
<li><a href="density-matrices.html#density-matrices"><span class="toc-section-number">9</span> Density matrices</a></li>
<li><a href="quantum-channels-or-cp-maps.html#quantum-channels-or-cp-maps"><span class="toc-section-number">10</span> Quantum channels (or CP maps)</a></li>
<li><a href="quantum-error-correction-and-fault-tolerance.html#quantum-error-correction-and-fault-tolerance"><span class="toc-section-number">11</span> Quantum error correction and fault tolerance</a></li>
<li><a href="bonus-things.html#bonus-things"><span class="toc-section-number">12</span> Bonus things</a></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="decoherence-and-elements-of-quantum-error-correction" class="section level1" number="8">
<h1><span class="header-section-number">Chapter 8</span> Decoherence, and elements of quantum error correction</h1>
<div class="comment">
<div class="book-only">
<p><a href="../tufte/decoherence-and-elements-of-quantum-error-correction.html#decoherence-and-elements-of-quantum-error-correction">Click here to view this entire chapter on one page.</a></p>
</div>
<div class="tufte-only">
<p><a href="../book/decoherence-and-elements-of-quantum-error-correction.html#decoherence-and-elements-of-quantum-error-correction">Click here to view this chapter in the book.</a></p>
</div>
</div>
<blockquote>
<p>On … <strong>!!!TODO!!!</strong></p>
</blockquote>
<p>In principle we know how to build a quantum computer: we can start with simple quantum logic gates and try to integrate them together into quantum networks.
However, if we keep on putting quantum gates together into networks we will quickly run into some serious practical problems.
The more interacting qubits involved, the harder it is to prevent them from getting entangled with the environment.
This unwelcome entanglement, also known as <strong>decoherence</strong>, destroys the interference, and thus the power, of quantum computing.</p>
<div id="decoherence-simplified" class="section level2" number="8.1">
<h2><span class="header-section-number">8.1</span> Decoherence simplified</h2>
<p>Consider the following qubit-environment interaction:
<span class="math display">\[
  \begin{aligned}
    |0\rangle|e\rangle &amp;\longmapsto |0\rangle|e_{00}\rangle
  \\|1\rangle|e\rangle &amp;\longmapsto |1\rangle|e_{11}\rangle
  \end{aligned}
\]</span>
where <span class="math inline">\(|e\rangle\)</span>, <span class="math inline">\(|e_{00}\rangle\)</span>, and <span class="math inline">\(|e_{11}\rangle\)</span> are the states of the environment, which not need to be orthogonal.<label for="tufte-sn-43" class="margin-toggle sidenote-number">43</label><input type="checkbox" id="tufte-sn-43" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">43</span> The reason we use two indices in <span class="math inline">\(|e_{00}\rangle\)</span> and <span class="math inline">\(|e_{11}\rangle\)</span> will become clear in a moment, when we consider more general interaction with the environment.</span>
Let <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span> be the initial state of the qubit.
The environment is essentially trying to <em>measure</em> the qubit and, as the result, the two get entangled:
<span class="math display">\[
  \Big( \alpha|0\rangle + \beta|1\rangle \Big) |e\rangle
  \longmapsto
  \alpha |0\rangle|e_{00}\rangle + \beta |1\rangle |e_{11}\rangle.
\]</span>
This state can also be written as
<span class="math display">\[
  \begin{aligned}
    \Big( \alpha|0\rangle + \beta|1\rangle \Big) |e\rangle
    \longmapsto
    &amp; \Big( \alpha|0\rangle + \beta|1\rangle \Big) \frac{|e_{00}\rangle+|e_{11}\rangle}{2}
  \\+&amp; \Big( \alpha|0\rangle - \beta|1\rangle \Big) \frac{|e_{00}\rangle-|e_{11}\rangle}{2}.
  \end{aligned}
\]</span>
or as
<span class="math display">\[
  |\psi\rangle|e\rangle
  \longmapsto
  \operatorname{id}|\psi\rangle|e_1\rangle + Z|\psi\rangle|e_z\rangle,
\]</span>
where <span class="math inline">\(|e_1\rangle = \frac12(|e_{00}\rangle + |e_{11}\rangle)\)</span> and <span class="math inline">\(|e_z\rangle = \frac12(|e_{00}\rangle - |e_{11}\rangle)\)</span>.
We may interpret this expression by saying that two things can happen to the qubit: nothing <span class="math inline">\(\operatorname{id}\)</span> (first term), or phase-flip <span class="math inline">\(Z\)</span> (second term).
This, however, should not be taken literally unless the states of the environment, <span class="math inline">\(|e_1\rangle\)</span> and <span class="math inline">\(|e_z\rangle\)</span>, are orthogonal.<label for="tufte-sn-44" class="margin-toggle sidenote-number">44</label><input type="checkbox" id="tufte-sn-44" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">44</span> Why not?</span></p>
</div>
<div id="decoherence-and-interference" class="section level2" number="8.2">
<h2><span class="header-section-number">8.2</span> Decoherence and interference</h2>
<p>Suppose the qubit undergoes the usual interference experiment but in between the two Hadamard gates it is affected by decoherence (denoted by <span class="math inline">\(\times\)</span>).</p>
<div class="figure" style="text-align: center"><span id="fig:decoherence-interference"></span>
<p class="caption marginnote shownote">
Figure 8.1: The usual interference experiment, but with decoherence.
</p>
<img src="quantum-site_files/figure-html/decoherence-interference-1.png" alt="The usual interference experiment, but with decoherence." width="384"  />
</div>
<p>Let us step through the circuit in Figure <a href="decoherence-and-elements-of-quantum-error-correction.html#fig:decoherence-interference">8.1</a>, keeping track of the state of the environment:
<span class="math display">\[
  \begin{aligned}
    |0\rangle|e\rangle
    &amp; \overset{H}{\longmapsto} \Big( |0\rangle + |1\rangle \Big) |e\rangle
  \\&amp; \overset{\phi}{\longmapsto} \Big( |0\rangle + e^{i\phi}|1\rangle \Big) |e\rangle
  \\&amp; \overset{\times}{\longmapsto} |0\rangle|e_0\rangle + e^{i\phi}|1\rangle|e_1\rangle
  \\&amp; \overset{H}{\longmapsto} |0\rangle\Big( |e_{00}\rangle + e^{i\phi}|e_{11}\rangle \Big) + |1\rangle\Big( |e_{00}\rangle - e^{i\phi}|e_{11}\rangle \Big).
  \end{aligned}
\]</span>
If we write <span class="math inline">\(\langle e_0|e_1\rangle = ve^{i\alpha}\)</span>, then the final probabilities of <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> oscillate with <span class="math inline">\(\phi\)</span> as
<span class="math display">\[
  \begin{aligned}
    P_{0}(\phi) &amp;= \frac12\big(1 + v\cos(\phi + \alpha)\big),
  \\P_{1}(\phi) &amp;= \frac12\big(1 - v\cos(\phi + \alpha)\big).
  \end{aligned}
\]</span></p>
<p>
<span class="marginnote shownote">
<!--
<div class="figure">--><span id="fig:visibility-suppression"></span>
<img src="quantum-site_files/figure-html/visibility-suppression-1.png" alt="Visibility suppression." width="384"  />
<!--
<p class="caption marginnote">-->Figure 8.2: Visibility suppression.<!--</p>-->
<!--</div>--></span>
</p>
<p>As we can see in Figure <a href="decoherence-and-elements-of-quantum-error-correction.html#fig:visibility-suppression">8.2</a>, the interference pattern is suppressed by a factor <span class="math inline">\(v\)</span>, which we call the <strong>visibility</strong>.
As <span class="math inline">\(v=|\!\langle e_0|e_1\rangle\!|\)</span> decreases, we lose all the advantages of quantum interference.
For example, in Deutsch’s algorithm we obtain the correct answer with probability at most <span class="math inline">\((1+v)/2\)</span>.
For <span class="math inline">\(\langle e_0|e_1\rangle = 0\)</span>, the perfect decoherence case, the network outputs <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> with equal probabilities, i.e. it is <em>useless</em> as a computing device.</p>
<div class="idea">
<p>It is clear that we want to avoid decoherence, or at least diminish its impact on our computing device.
For this we need <strong>quantum error correction</strong>: we encode the state of a single (logical) qubit across several (physical) qubits.</p>
</div>
</div>
<div id="evolution-of-density-operators-under-decoherence" class="section level2" number="8.3">
<h2><span class="header-section-number">8.3</span> Evolution of density operators under decoherence</h2>
<p>In terms of density operators, the qubit alone evolves from the pure state <span class="math inline">\(|\psi\rangle\langle\psi|\)</span> to a mixed state, which can be obtained by tracing over the environment.
We start with the evolution of the state vector <span class="math inline">\(|\psi\rangle=\alpha|0\rangle+\beta|1\rangle\)</span>, which is given by
<span class="math display">\[
  \left( \alpha|0\rangle +\beta |1\rangle\right)|e\rangle \longmapsto
  \alpha |0\rangle|e_{00}\rangle +\beta |1\rangle |e_{11}\rangle,
\]</span>
Then we write it as the evolution of the projector <span class="math inline">\(|\psi\rangle\langle\psi|\)</span>, and trace over the environment to obtain
<span class="math display">\[
  \begin{aligned}
    |\psi\rangle\langle\psi| \longmapsto &amp; |\alpha|^2|0\rangle\langle 0| \langle e_{00}|e_{00}\rangle+ \alpha\beta^\star |0\rangle\!\langle 1|\langle e_{11}|e_{00}\rangle
  \\+ &amp;\alpha^\star\beta |1\rangle\!\langle 0|\langle e_{00}|e_{11}\rangle  + |\beta|^2|1\rangle\langle 1|\langle e_{11}|e_{11}\rangle.
  \end{aligned}
\]</span>
Written in the matrix form, this is
<span class="math display">\[
  \begin{bmatrix}
    |\alpha|^2 &amp; \alpha\beta^\ast
  \\\alpha^\ast\beta &amp; |\beta|^2
  \end{bmatrix}
  \longmapsto
  \begin{bmatrix}
    |\alpha|^2 &amp; \alpha\beta^\ast \langle e_{11}|e_{00}\rangle
    \\\alpha^\ast\beta \langle e_{00}|e_{11}\rangle &amp; |\beta|^2
  \end{bmatrix}.
\]</span>
The off-diagonal elements, originally called <strong>coherences</strong>, vanish as <span class="math inline">\(\langle e_0|e_1\rangle\)</span> approaches zero.
This is why this particular interaction is called decoherence.</p>
<p>Notice that
<span class="math display">\[
|\psi\rangle|e\rangle \longmapsto \operatorname{id}|\psi\rangle|e_1\rangle +Z|\psi\rangle|e_z\rangle,
\]</span>
implies
<span class="math display">\[
|\psi\rangle\langle\psi|\longmapsto \operatorname{id}|\psi\rangle\langle\psi| \operatorname{id}\langle e_1|e_1\rangle +Z|\psi\rangle\langle\psi| Z\langle e_z|e_z\rangle,
\]</span>
<em>only</em> when <span class="math inline">\(\langle e_1|e_z\rangle=0\)</span> (otherwise you would have additional cross terms <span class="math inline">\(\operatorname{id}|\psi\rangle\langle\psi| Z\)</span> and <span class="math inline">\(Z|\psi\rangle\langle\psi| \operatorname{id}\)</span>).
In this case we can indeed say that, with probability <span class="math inline">\(\langle e_1|e_1\rangle\)</span>, nothing happens, and, with probability <span class="math inline">\(\langle e_z|e_z\rangle\)</span>, the qubit undergoes the phase-flip <span class="math inline">\(Z\)</span>.</p>
</div>
<div id="quantum-errors" class="section level2" number="8.4">
<h2><span class="header-section-number">8.4</span> Quantum errors</h2>
<p>The most general qubit-environment interaction
<span class="math display">\[
  \begin{aligned}
    |0\rangle|e\rangle &amp;\longmapsto |0\rangle|e_{00}\rangle + |1\rangle|e_{01}\rangle,
  \\|1\rangle|e\rangle &amp;\longmapsto |1\rangle|e_{10}\rangle + |0\rangle|e_{11}\rangle,
  \end{aligned}
\]</span>
where the states of the environment are neither normalised nor orthogonal, leads to decoherence
<span class="math display">\[
  \begin{aligned}
    \Big( \alpha|0\rangle + \beta|1\rangle \Big) |e\rangle \longmapsto
    &amp; \Big( \alpha|0\rangle + \beta|1\rangle \Big) \frac{|e_{00}\rangle+|e_{11}\rangle}{2}
  \\+&amp; \Big( \alpha|0\rangle - \beta|1\rangle \Big) \frac{|e_{00}\rangle-|e_{11}\rangle}{2}
  \\+&amp; \Big( \alpha|1\rangle + \beta|0\rangle \Big) \frac{|e_{01}\rangle+|e_{10}\rangle}{2}
  \\+&amp; \Big( \alpha|1\rangle - \beta|0\rangle \Big) \frac{|e_{01}\rangle-|e_{10}\rangle}{2}.
  \end{aligned}
\]</span>
We can also write this as
<span class="math display">\[
|\psi\rangle|e\rangle \longmapsto  \operatorname{id}|\psi\rangle|e_1\rangle + Z|\psi\rangle |e_z\rangle +X|\psi\rangle |e_x\rangle + Y|\psi\rangle |e_y\rangle.
\]</span>
The intuition behind this expression is that four things can happen to the qubit:</p>
<ol style="list-style-type: decimal">
<li>nothing (<span class="math inline">\(\operatorname{id}\)</span>),</li>
<li>phase-flip (<span class="math inline">\(Z\)</span>),</li>
<li>bit-flip (<span class="math inline">\(X\)</span>), or</li>
<li>both bit-flip and phase-flip (<span class="math inline">\(Y\)</span>).</li>
</ol>
<p>This is certainly the case when the states <span class="math inline">\(|e_1\rangle, |e_x\rangle, |e_y\rangle\)</span> and <span class="math inline">\(|e_z\rangle\)</span> are mutually orthogonal, otherwise we cannot perfectly distinguish between the four alternatives.</p>
<div class="idea">
<p>What is important here is the discretisation of errors, and the fact that we can reduce quantum errors to <em>two types</em>: bit-flip errors <span class="math inline">\(X\)</span>, and phase-flip errors <span class="math inline">\(Z\)</span>.</p>
</div>
<p>In general, given <span class="math inline">\(n\)</span> qubits in state <span class="math inline">\(|\psi\rangle\)</span> and the environment in state <span class="math inline">\(|e\rangle\)</span> the joint evolution can be expanded as
<span class="math display">\[
|\psi\rangle|e\rangle \longmapsto \sum_i E_i|\psi\rangle|e_i\rangle,
\]</span>
where the <span class="math inline">\(E_i\)</span> are the <span class="math inline">\(n\)</span>-fold tensor products of the Pauli operators and the <span class="math inline">\(|e_i\rangle\)</span> are the corresponding states of the environment, which are not assumed to be normalised or mutually orthogonal.
A typical operator <span class="math inline">\(E_i\)</span> acting on five qubits may look like this,
<span class="math display">\[
  X\otimes Z \otimes \operatorname{id}\otimes \operatorname{id}\otimes Y
  \equiv XZ\operatorname{id}\operatorname{id}Y.
\]</span>
We can say that <span class="math inline">\(E_i\)</span> represents an error consisting of the bit (<span class="math inline">\(X\)</span>) error on the first qubit, phase (<span class="math inline">\(Z\)</span>) error on the second qubit and both bit and phase (<span class="math inline">\(Y\)</span>) error on the fifth qubit.
Again, <em>this is not quite accurate if the corresponding states of the environment are not mutually orthogonal</em>, but it gives the right kind of intuition nonetheless.
Here the index <span class="math inline">\(i\)</span> in <span class="math inline">\(E_i\)</span> ranges from <span class="math inline">\(1\)</span> to <span class="math inline">\(4^5=1024\)</span>, because there are <span class="math inline">\(4^5\)</span> different Pauli operators acting on <span class="math inline">\(5\)</span> qubits.</p>
</div>
<div id="same-evolution-different-errors" class="section level2" number="8.5">
<h2><span class="header-section-number">8.5</span> Same evolution, different errors</h2>
<p>We can always pick up an orthonormal basis <span class="math inline">\(|u_i\rangle\)</span> in the environment and express the system–environment evolution as
<span class="math display">\[
  \begin{aligned}
    |\psi\rangle|e\rangle
    \longmapsto &amp;\sum_{ij} E_i|\psi\rangle|u_j\rangle\langle u_j|e_i\rangle
    \\&amp;= \sum_{j}\Big( \sum_i \langle u_j|e_i\rangle E_i\Big)|\psi\rangle|u_j\rangle
    \\&amp;= \sum_j M_j|\psi\rangle|u_j\rangle.
  \end{aligned}
\]</span>
The new “error” operators <span class="math inline">\(M_j\)</span> satisfy <span class="math inline">\(\sum_j M_j^\dagger M_j =\operatorname{id}\)</span> and, in general, they are <em>not</em> unitary.
Now, the evolution of the density operator <span class="math inline">\(|\psi\rangle\langle\psi|\)</span> can be written as
<span class="math display">\[
  |\psi\rangle\langle\psi|\longmapsto \sum_j M_j|\psi\rangle\langle\psi| M_j^\dagger.
\]</span>
Which particular errors you choose depends of your choice of the basis in the environment.
If, instead of <span class="math inline">\(|u_j\rangle\)</span>, you pick up a different basis, say <span class="math inline">\(|v_k\rangle\)</span>, then
<span class="math display">\[
  \begin{aligned}
    |\psi\rangle|e\rangle
    \longmapsto &amp;\sum_j M_j|\psi\rangle|u_j\rangle
  \\&amp;= \sum_j M_j |\psi\rangle\sum_k|v_k\rangle\langle v_k|u_j\rangle
  \\&amp;= \sum_k \Big(\sum_j \langle v_k|u_j\rangle M_j \Big)|\psi\rangle|v_k\rangle
  \\&amp;= \sum_k N_k|\psi\rangle|v_k\rangle,
  \end{aligned}
\]</span>
and, consequently,
<span class="math display">\[
  |\psi\rangle\langle\psi|\longmapsto \sum_k N_k|\psi\rangle\langle\psi| N_k^\dagger.
\]</span>
The new “errors” satisfy <span class="math inline">\(\sum_k N_k^\dagger N_k = \operatorname{id}\)</span>, and the error operators <span class="math inline">\(N_k\)</span> and <span class="math inline">\(M_j\)</span> are related by the unitary matrix <span class="math inline">\(U_{kj}=\langle v_k|u_j\rangle\)</span>.</p>
</div>
<div id="some-errors-can-be-corrected-on-some-states" class="section level2" number="8.6">
<h2><span class="header-section-number">8.6</span> Some errors can be corrected on some states</h2>
<p>Alice prepares a quantum object in some state <span class="math inline">\(|\psi\rangle\)</span> and sends it to Bob.
The object is intercepted by a malicious Eve who changes its state by applying one of the prescribed unitary operations <span class="math inline">\(U_1,\ldots, U_n\)</span>, with probabilities <span class="math inline">\(p_1,\ldots, p_n\)</span>, respectively.
Alice and Bob know the set of possible unitaries (errors), and the associated probabilities, but they do not know which particular unitary operation was chosen by Eve.
Can Bob reconstruct the state <span class="math inline">\(|\psi\rangle\)</span>?
The answer is affirmative, at least for <em>some states</em> <span class="math inline">\(|\psi\rangle\)</span>.</p>
<p>Let <span class="math inline">\(\mathcal{H}\)</span> be the Hilbert space pertaining to the object, and let <span class="math inline">\(\mathcal{C}\)</span> be a subspace of <span class="math inline">\(\mathcal{H}\)</span>.
Suppose <span class="math inline">\(|\psi\rangle\in\mathcal{C}\)</span>, and that, for each vector in <span class="math inline">\(\mathcal{C}\)</span>, we have
<span class="math display">\[
  \langle\psi|U^\dagger_i U_j|\psi\rangle = \delta_{ij}
\]</span>
Any error <span class="math inline">\(U_k\)</span> transforms the subspace <span class="math inline">\(\mathcal{C}\)</span> into the subspace <span class="math inline">\(\mathcal{C}_k\)</span>, which is orthogonal to <span class="math inline">\(\mathcal{C}\)</span> and also to any other subspace <span class="math inline">\(\mathcal{C}_j\)</span> for <span class="math inline">\(j\neq k\)</span>.
All Bob has to do is
- perform a measurement, defined by projectors on the subspaces <span class="math inline">\(\mathcal{C}_j\)</span> for <span class="math inline">\(j=1,\ldots n\)</span>,
- identify <span class="math inline">\(k\)</span>, and
- apply <span class="math inline">\(U_k^\dagger\)</span>.</p>
<p>As an example, consider an object composed of three qubits and the subspace <span class="math inline">\(\mathcal{C}\)</span> spanned by the two basis vectors <span class="math inline">\(|000\rangle\)</span> and <span class="math inline">\(|111\rangle\)</span>.
Suppose Eve applies one of the following four unitary operations: <span class="math inline">\(U_0=\operatorname{id}\otimes\operatorname{id}\otimes \operatorname{id}\)</span>, <span class="math inline">\(U_1 =X\otimes\operatorname{id}\otimes \operatorname{id}\)</span>, <span class="math inline">\(U_2 =\operatorname{id}\otimes X\otimes \operatorname{id}\)</span>, and <span class="math inline">\(U_3=\operatorname{id}\otimes\operatorname{id}\otimes X\)</span>.
That is, the identity, or bit-flip on the first, second, or third qubit.
Each operation is chosen randomly with the same probability of <span class="math inline">\(1/4\)</span>.
It is easy to see that the four operations generate four subspaces:
<span class="math display">\[
  \begin{aligned}
    \mathcal{C} = \Big\langle|000\rangle,|111\rangle\Big\rangle &amp;\qquad \mathcal{C}_1 = \Big\langle|100\rangle,|011\rangle\Big\rangle
  \\\mathcal{C}_2 = \Big\langle|010\rangle,|101\rangle\Big\rangle&amp; \qquad \mathcal{C}_3 = \Big\langle|001\rangle,|110\rangle\Big\rangle.
  \end{aligned}
\]</span>
The eight dimensional Hilbert space of the three qubits is then decomposed into the sum of orthogonal subspaces
<span class="math display">\[
\mathcal{C} \oplus \mathcal{C}_1 \oplus\mathcal{C}_2 \oplus \mathcal{C}_3
\]</span>
So suppose Alice prepares <span class="math inline">\(|\psi\rangle=\alpha|000\rangle+\beta|111\rangle\)</span> and Eve applies the bit-flip to the third qubit.
This generates the state <span class="math inline">\(\operatorname{id}\otimes\operatorname{id}\otimes X|\psi\rangle=\alpha|001\rangle+\beta|110\rangle\in \mathcal{C}_3\)</span>.
The projective measurement on these subspaces tells Bob that the new state is in the subspace <span class="math inline">\(\mathcal{C}_3\)</span>, and hence the original state can be recovered by the operation <span class="math inline">\(\operatorname{id}\otimes\operatorname{id}\otimes X\)</span>.</p>
</div>
<div id="repetition-codes" class="section level2" number="8.7">
<h2><span class="header-section-number">8.7</span> Repetition codes</h2>
<p>In order to give a sense of how quantum error correction actually works, let us begin with a <em>classical</em> example of a repetition code.
Suppose a transmission channel flips each bit in transit with probability <span class="math inline">\(p\)</span>.
If this error rate is considered too high then it can be decreased by encoding each bit into, say, three bits:
<span class="math display">\[
  \begin{aligned}
    0 &amp;\mapsto 000
  \\1 &amp;\mapsto 111.
  \end{aligned}
\]</span>
That is, each time we want to send logical <span class="math inline">\(0\)</span>, we send three physical bits, all in state <span class="math inline">\(0\)</span>; each time we want to send logical <span class="math inline">\(1\)</span>, we send three physical bits, all in state <span class="math inline">\(1\)</span>.
The receiver decodes the bit value by a “majority vote” of the three bits.
If only one error occurs, then this error correction procedure is foolproof.
In general, the net probability of error is just the likelihood that two or three errors occur, which is <span class="math inline">\(3p^2(1-p) + p^3 &lt; p\)</span>.
Thus the three bit code improves the reliability of the information transfer.
The <em>quantum</em> case, however, is more complicated, because we have both bit-flip <em>and</em> phase-flip errors.</p>
</div>
<div id="quantum-error-correction" class="section level2" number="8.8">
<h2><span class="header-section-number">8.8</span> Quantum error correction</h2>
<p>In order to protect a qubit against bit-flips (incoherent <span class="math inline">\(X\)</span> rotations), we rely on the same repetition code, but both encoding and error correction is now done by quantum operations.
We take a qubit in some unknown pure state <span class="math inline">\(\alpha|0\rangle + \beta|1\rangle\)</span>, introduce two auxiliary qubits, and encode it into three qubits as</p>
<p><img src="quantum-site_files/figure-html/unnamed-chunk-23-1.png" width="768"  style="display: block; margin: auto;" /></p>
<p>Suppose that at most one qubit is then flipped (say, the second one).
The encoded state then becomes <span class="math inline">\(\alpha|010\rangle + \beta|101\rangle\)</span>.
Decoding requires some care: if we measure the three qubits directly it would destroy the superposition of states that we are working so hard to protect.
Instead we introduce another two additional qubits, both in state <span class="math inline">\(|0\rangle\)</span>, and apply the following network:</p>
<p><img src="quantum-site_files/figure-html/unnamed-chunk-24-1.png" width="768"  style="display: block; margin: auto;" /></p>
<p>We measure the two auxiliary qubits, also known as <strong>ancilla bits</strong>, and the result of the measurement, known as the <strong>error syndrome</strong>, tells us how to reset the three qubits of the code.
The theory behind this network runs as follows.</p>
<p>If qubits one and two (counting from the top) are the same, then the first ancilla is in the <span class="math inline">\(|0\rangle\)</span> state.
Similarly, if qubits two and three are the same, then the second ancilla is in the <span class="math inline">\(|0\rangle\)</span> state.
However, if they are different, then the corresponding ancilla is in the <span class="math inline">\(|1\rangle\)</span> state.
Hence, the four possible error syndromes — <span class="math inline">\(|00\rangle\)</span>, <span class="math inline">\(|01\rangle\)</span>, <span class="math inline">\(|10\rangle\)</span>, and <span class="math inline">\(|11\rangle\)</span> — each indicate a different possibility: no errors, an error in the third, first, or second qubits (respectively).
In our example, we would measure <span class="math inline">\(|11\rangle\)</span>, revealing that both qubits 1 and 2, and qubits 2 and 3, are different.
Thus it is qubit 2 that has an error.
Knowing the error, we can go back and fix it, simply by applying <span class="math inline">\(X\)</span> to qubit 2.
The net result is the state <span class="math inline">\(\alpha|000\rangle + \beta|111\rangle\)</span>, which is then turned into <span class="math inline">\((\alpha|0\rangle + \beta|1\rangle)|0\rangle|0\rangle\)</span> by running the mirror image of the encoding network.</p>
</div>
<div id="turning-bit-flips-into-phase-flips" class="section level2" number="8.9">
<h2><span class="header-section-number">8.9</span> Turning bit-flips into phase-flips</h2>
<p>The three-qubit code that we have just demonstrated is sufficient to protect a qubit against single bit-flips, but not phase-flips.
But this is good enough.
Recall that <span class="math inline">\(HZH=X\)</span>, and so it is enough to sandwich the decoherence area in between the Hadamard gates: they will turn phase flips into bit flips, and we already know hot to protect our qubits against <span class="math inline">\(Z\)</span>-errors.
The encoded state <span class="math inline">\(\alpha|0\rangle + \beta|1\rangle\)</span> now reads <span class="math inline">\(\alpha|+++\rangle+\beta|---\rangle\)</span>, where <span class="math inline">\(|\pm\rangle=|0\rangle\pm|1\rangle\)</span>.</p>
</div>
<div id="dealing-with-bit-flip-and-phase-flip-errors" class="section level2" number="8.10">
<h2><span class="header-section-number">8.10</span> Dealing with bit-flip and phase-flip errors</h2>
<p>We can now put the bit-flip and phase-flip codes together: first we encode the qubit using the phase-flip code, and then we encode each of the three qubits of the code using the bit-flip code.
This gives an error correction scheme that allows us to protect against both types of error, thus yielding a code that encodes a single logical qubit across nine physical qubits, protecting against a single quantum error on any of the nine qubits.</p>
<p>If we want to preserve a quantum state for a long time without doing any computations, or if we want to send it through a noisy communications channel, we can just encode the state using a quantum code and decode it when we are done.
Computation on encoded states using noisy gates requires few more tricks (to be completed).</p>

</div>
</div>
<p style="text-align: center;">
<a href="bells-theorem.html"><button class="btn btn-default">Previous</button></a>
<a href="density-matrices.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
