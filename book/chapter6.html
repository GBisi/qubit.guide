<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 6 Quantum algorithms | Lectures on Quantum Information Science</title>
  <meta name="description" content="The online book version of an introductory series of lectures on quantum computing." />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 6 Quantum algorithms | Lectures on Quantum Information Science" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="The online book version of an introductory series of lectures on quantum computing." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 6 Quantum algorithms | Lectures on Quantum Information Science" />
  
  <meta name="twitter:description" content="The online book version of an introductory series of lectures on quantum computing." />
  

<meta name="author" content="Artur Ekert and Tim Hosgood" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="chapter5.html"/>
<link rel="next" href="chapter7.html"/>
<script src="libs/header-attrs-2.5.3/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>



<link rel="stylesheet" href="gitbook-custom.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="https://thosgood.com/quantum-info/">Quantum Information Science</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Introduction</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#plan"><i class="fa fa-check"></i>Plan</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#topics"><i class="fa fa-check"></i>Topics</a></li>
<li class="chapter" data-level="0.1" data-path="index.html"><a href="index.html#some-mathematical-preliminaries"><i class="fa fa-check"></i><b>0.1</b> Some mathematical preliminaries</a>
<ul>
<li class="chapter" data-level="0.1.1" data-path="index.html"><a href="index.html#euclidean-vectors"><i class="fa fa-check"></i><b>0.1.1</b> Euclidean vectors</a></li>
<li class="chapter" data-level="0.1.2" data-path="index.html"><a href="index.html#vector-spaces"><i class="fa fa-check"></i><b>0.1.2</b> Vector spaces</a></li>
<li class="chapter" data-level="0.1.3" data-path="index.html"><a href="index.html#bras-and-kets"><i class="fa fa-check"></i><b>0.1.3</b> Bras and Kets</a></li>
<li class="chapter" data-level="0.1.4" data-path="index.html"><a href="index.html#daggers"><i class="fa fa-check"></i><b>0.1.4</b> Daggers</a></li>
<li class="chapter" data-level="0.1.5" data-path="index.html"><a href="index.html#geometry"><i class="fa fa-check"></i><b>0.1.5</b> Geometry</a></li>
<li class="chapter" data-level="0.1.6" data-path="index.html"><a href="index.html#operators"><i class="fa fa-check"></i><b>0.1.6</b> Operators</a></li>
<li class="chapter" data-level="0.1.7" data-path="index.html"><a href="index.html#outer-products"><i class="fa fa-check"></i><b>0.1.7</b> Outer products</a></li>
<li class="chapter" data-level="0.1.8" data-path="index.html"><a href="index.html#the-trace"><i class="fa fa-check"></i><b>0.1.8</b> The trace</a></li>
<li class="chapter" data-level="0.1.9" data-path="index.html"><a href="index.html#some-useful-identities"><i class="fa fa-check"></i><b>0.1.9</b> Some useful identities</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>I Budding</b></span></li>
<li class="chapter" data-level="1" data-path="chapter1.html"><a href="chapter1.html"><i class="fa fa-check"></i><b>1</b> Quantum interference: an overview</a>
<ul>
<li class="chapter" data-level="1.1" data-path="chapter1.html"><a href="chapter1.html#two-basic-rules"><i class="fa fa-check"></i><b>1.1</b> Two basic rules</a></li>
<li class="chapter" data-level="1.2" data-path="chapter1.html"><a href="chapter1.html#quantum-interference-the-failure-of-probability-theory"><i class="fa fa-check"></i><b>1.2</b> Quantum interference: the failure of probability theory</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="chapter1.html"><a href="chapter1.html#the-double-slit-experiment"><i class="fa fa-check"></i><b>1.2.1</b> The double slit experiment</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="chapter1.html"><a href="chapter1.html#superpositions"><i class="fa fa-check"></i><b>1.3</b> Superpositions</a></li>
<li class="chapter" data-level="1.4" data-path="chapter1.html"><a href="chapter1.html#interferometers"><i class="fa fa-check"></i><b>1.4</b> Interferometers</a></li>
<li class="chapter" data-level="1.5" data-path="chapter1.html"><a href="chapter1.html#qubits-gates-and-circuits"><i class="fa fa-check"></i><b>1.5</b> Qubits, gates, and circuits</a></li>
<li class="chapter" data-level="1.6" data-path="chapter1.html"><a href="chapter1.html#quantum-decoherence"><i class="fa fa-check"></i><b>1.6</b> Quantum decoherence</a></li>
<li class="chapter" data-level="1.7" data-path="chapter1.html"><a href="chapter1.html#computation-deterministic-probabilistic-and-quantum"><i class="fa fa-check"></i><b>1.7</b> Computation: deterministic, probabilistic, and quantum</a></li>
<li class="chapter" data-level="1.8" data-path="chapter1.html"><a href="chapter1.html#computational-complexity"><i class="fa fa-check"></i><b>1.8</b> Computational complexity</a></li>
<li class="chapter" data-level="1.9" data-path="chapter1.html"><a href="chapter1.html#outlook"><i class="fa fa-check"></i><b>1.9</b> Outlook</a></li>
<li class="chapter" data-level="1.10" data-path="chapter1.html"><a href="chapter1.html#remarks-and-exercises"><i class="fa fa-check"></i><b>1.10</b> Remarks and exercises</a>
<ul>
<li class="chapter" data-level="1.10.1" data-path="chapter1.html"><a href="chapter1.html#section"><i class="fa fa-check"></i><b>1.10.1</b> </a></li>
<li class="chapter" data-level="1.10.2" data-path="chapter1.html"><a href="chapter1.html#section-1"><i class="fa fa-check"></i><b>1.10.2</b> </a></li>
<li class="chapter" data-level="1.10.3" data-path="chapter1.html"><a href="chapter1.html#section-2"><i class="fa fa-check"></i><b>1.10.3</b> </a></li>
<li class="chapter" data-level="1.10.4" data-path="chapter1.html"><a href="chapter1.html#section-3"><i class="fa fa-check"></i><b>1.10.4</b> </a></li>
<li class="chapter" data-level="1.10.5" data-path="chapter1.html"><a href="chapter1.html#section-4"><i class="fa fa-check"></i><b>1.10.5</b> </a></li>
<li class="chapter" data-level="1.10.6" data-path="chapter1.html"><a href="chapter1.html#physics-against-logic"><i class="fa fa-check"></i><b>1.10.6</b> Physics against logic?</a></li>
<li class="chapter" data-level="1.10.7" data-path="chapter1.html"><a href="chapter1.html#quantum-bomb-tester"><i class="fa fa-check"></i><b>1.10.7</b> Quantum bomb tester</a></li>
<li class="chapter" data-level="1.10.8" data-path="chapter1.html"><a href="chapter1.html#section-5"><i class="fa fa-check"></i><b>1.10.8</b> </a></li>
<li class="chapter" data-level="1.10.9" data-path="chapter1.html"><a href="chapter1.html#section-6"><i class="fa fa-check"></i><b>1.10.9</b> </a></li>
<li class="chapter" data-level="1.10.10" data-path="chapter1.html"><a href="chapter1.html#section-7"><i class="fa fa-check"></i><b>1.10.10</b> </a></li>
<li class="chapter" data-level="1.10.11" data-path="chapter1.html"><a href="chapter1.html#section-8"><i class="fa fa-check"></i><b>1.10.11</b> </a></li>
<li class="chapter" data-level="1.10.12" data-path="chapter1.html"><a href="chapter1.html#section-9"><i class="fa fa-check"></i><b>1.10.12</b> </a></li>
<li class="chapter" data-level="1.10.13" data-path="chapter1.html"><a href="chapter1.html#section-10"><i class="fa fa-check"></i><b>1.10.13</b> </a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="chapter2.html"><a href="chapter2.html"><i class="fa fa-check"></i><b>2</b> Qubits</a>
<ul>
<li class="chapter" data-level="2.1" data-path="chapter2.html"><a href="chapter2.html#composing-quantum-operations"><i class="fa fa-check"></i><b>2.1</b> Composing quantum operations</a></li>
<li class="chapter" data-level="2.2" data-path="chapter2.html"><a href="chapter2.html#quantum-bits-called-qubits"><i class="fa fa-check"></i><b>2.2</b> Quantum bits, called “qubits”</a></li>
<li class="chapter" data-level="2.3" data-path="chapter2.html"><a href="chapter2.html#quantum-gates-and-circuits"><i class="fa fa-check"></i><b>2.3</b> Quantum gates and circuits</a></li>
<li class="chapter" data-level="2.4" data-path="chapter2.html"><a href="chapter2.html#single-qubit-interference"><i class="fa fa-check"></i><b>2.4</b> Single qubit interference</a></li>
<li class="chapter" data-level="2.5" data-path="chapter2.html"><a href="chapter2.html#the-square-root-of-not"><i class="fa fa-check"></i><b>2.5</b> The square root of NOT</a></li>
<li class="chapter" data-level="2.6" data-path="chapter2.html"><a href="chapter2.html#phase-gates-galore"><i class="fa fa-check"></i><b>2.6</b> Phase gates galore</a></li>
<li class="chapter" data-level="2.7" data-path="chapter2.html"><a href="chapter2.html#pauli-operators"><i class="fa fa-check"></i><b>2.7</b> Pauli operators</a></li>
<li class="chapter" data-level="2.8" data-path="chapter2.html"><a href="chapter2.html#from-bit-flips-to-phase-flips-and-back-again"><i class="fa fa-check"></i><b>2.8</b> From bit-flips to phase-flips, and back again</a></li>
<li class="chapter" data-level="2.9" data-path="chapter2.html"><a href="chapter2.html#any-unitary-operation-on-a-single-qubit"><i class="fa fa-check"></i><b>2.9</b> Any unitary operation on a single qubit</a></li>
<li class="chapter" data-level="2.10" data-path="chapter2.html"><a href="chapter2.html#the-bloch-sphere"><i class="fa fa-check"></i><b>2.10</b> The Bloch sphere</a></li>
<li class="chapter" data-level="2.11" data-path="chapter2.html"><a href="chapter2.html#composition-of-rotations"><i class="fa fa-check"></i><b>2.11</b> Composition of rotations</a></li>
<li class="chapter" data-level="2.12" data-path="chapter2.html"><a href="chapter2.html#a-finite-set-of-universal-gates"><i class="fa fa-check"></i><b>2.12</b> A finite set of universal gates</a></li>
<li class="chapter" data-level="2.13" data-path="chapter2.html"><a href="chapter2.html#exercises"><i class="fa fa-check"></i><b>2.13</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="chapter3.html"><a href="chapter3.html"><i class="fa fa-check"></i><b>3</b> Logic and geometry with quantum gates</a>
<ul>
<li class="chapter" data-level="3.1" data-path="chapter3.html"><a href="chapter3.html#physics-against-logic-via-beamsplitters"><i class="fa fa-check"></i><b>3.1</b> Physics against logic, via beamsplitters</a></li>
<li class="chapter" data-level="3.2" data-path="chapter3.html"><a href="chapter3.html#quantum-interference-revisited-still-about-beam-splitters"><i class="fa fa-check"></i><b>3.2</b> Quantum interference revisited (still about beam-splitters)</a></li>
<li class="chapter" data-level="3.3" data-path="chapter3.html"><a href="chapter3.html#the-pauli-matrices-algebraically"><i class="fa fa-check"></i><b>3.3</b> The Pauli matrices, algebraically</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="chapter3.html"><a href="chapter3.html#exercises-1"><i class="fa fa-check"></i><b>3.3.1</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="chapter3.html"><a href="chapter3.html#the-pauli-matrices-geometrically"><i class="fa fa-check"></i><b>3.4</b> The Pauli matrices, geometrically</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="chapter3.html"><a href="chapter3.html#exercises-2"><i class="fa fa-check"></i><b>3.4.1</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="chapter3.html"><a href="chapter3.html#unitaries-as-rotations"><i class="fa fa-check"></i><b>3.5</b> Unitaries as rotations</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="chapter3.html"><a href="chapter3.html#exercises-3"><i class="fa fa-check"></i><b>3.5.1</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="chapter3.html"><a href="chapter3.html#universality-again"><i class="fa fa-check"></i><b>3.6</b> Universality, again</a>
<ul>
<li class="chapter" data-level="3.6.1" data-path="chapter3.html"><a href="chapter3.html#exercises-4"><i class="fa fa-check"></i><b>3.6.1</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="chapter3.html"><a href="chapter3.html#quantum-dynamics"><i class="fa fa-check"></i><b>3.7</b> Some quantum dynamics</a>
<ul>
<li class="chapter" data-level="3.7.1" data-path="chapter3.html"><a href="chapter3.html#exercises-5"><i class="fa fa-check"></i><b>3.7.1</b> Exercises</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="chapter4.html"><a href="chapter4.html"><i class="fa fa-check"></i><b>4</b> Measurements</a>
<ul>
<li class="chapter" data-level="4.1" data-path="chapter4.html"><a href="chapter4.html#hilbert-spaces-briefly"><i class="fa fa-check"></i><b>4.1</b> Hilbert spaces, briefly</a></li>
<li class="chapter" data-level="4.2" data-path="chapter4.html"><a href="chapter4.html#back-to-qubits-complete-measurements"><i class="fa fa-check"></i><b>4.2</b> Back to qubits; complete measurements</a></li>
<li class="chapter" data-level="4.3" data-path="chapter4.html"><a href="chapter4.html#the-projection-rule-incomplete-measurements"><i class="fa fa-check"></i><b>4.3</b> The projection rule; incomplete measurements</a></li>
<li class="chapter" data-level="4.4" data-path="chapter4.html"><a href="chapter4.html#example-of-an-incomplete-measurement"><i class="fa fa-check"></i><b>4.4</b> Example of an incomplete measurement</a></li>
<li class="chapter" data-level="4.5" data-path="chapter4.html"><a href="chapter4.html#observables"><i class="fa fa-check"></i><b>4.5</b> Observables</a></li>
<li class="chapter" data-level="4.6" data-path="chapter4.html"><a href="chapter4.html#compatible-observables-and-the-uncertainty-relation"><i class="fa fa-check"></i><b>4.6</b> Compatible observables and the uncertainty relation</a></li>
<li class="chapter" data-level="4.7" data-path="chapter4.html"><a href="chapter4.html#quantum-communication"><i class="fa fa-check"></i><b>4.7</b> Quantum communication</a></li>
<li class="chapter" data-level="4.8" data-path="chapter4.html"><a href="chapter4.html#basic-quantum-coding-and-decoding"><i class="fa fa-check"></i><b>4.8</b> Basic quantum coding and decoding</a></li>
<li class="chapter" data-level="4.9" data-path="chapter4.html"><a href="chapter4.html#distinguishability-of-non-orthogonal-states"><i class="fa fa-check"></i><b>4.9</b> Distinguishability of non-orthogonal states</a></li>
<li class="chapter" data-level="4.10" data-path="chapter4.html"><a href="chapter4.html#wiesners-quantum-money"><i class="fa fa-check"></i><b>4.10</b> Wiesner’s quantum money</a></li>
<li class="chapter" data-level="4.11" data-path="chapter4.html"><a href="chapter4.html#exercises-6"><i class="fa fa-check"></i><b>4.11</b> Exercises</a></li>
<li class="chapter" data-level="4.12" data-path="chapter4.html"><a href="chapter4.html#quantum-theory-formally"><i class="fa fa-check"></i><b>4.12</b> Quantum theory, formally</a>
<ul>
<li class="chapter" data-level="4.12.1" data-path="chapter4.html"><a href="chapter4.html#quantum-states"><i class="fa fa-check"></i><b>4.12.1</b> Quantum states</a></li>
<li class="chapter" data-level="4.12.2" data-path="chapter4.html"><a href="chapter4.html#quantum-evolutions"><i class="fa fa-check"></i><b>4.12.2</b> Quantum evolutions</a></li>
<li class="chapter" data-level="4.12.3" data-path="chapter4.html"><a href="chapter4.html#quantum-circuits"><i class="fa fa-check"></i><b>4.12.3</b> Quantum circuits</a></li>
<li class="chapter" data-level="4.12.4" data-path="chapter4.html"><a href="chapter4.html#measurements"><i class="fa fa-check"></i><b>4.12.4</b> Measurements</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="chapter5.html"><a href="chapter5.html"><i class="fa fa-check"></i><b>5</b> Quantum entanglement</a>
<ul>
<li class="chapter" data-level="5.1" data-path="chapter5.html"><a href="chapter5.html#a-small-history"><i class="fa fa-check"></i><b>5.1</b> A small history</a></li>
<li class="chapter" data-level="5.2" data-path="chapter5.html"><a href="chapter5.html#one-two-many"><i class="fa fa-check"></i><b>5.2</b> One, two, many…</a></li>
<li class="chapter" data-level="5.3" data-path="chapter5.html"><a href="chapter5.html#quantum-theory-formally-continued"><i class="fa fa-check"></i><b>5.3</b> Quantum theory, formally (continued)</a>
<ul>
<li class="chapter" data-level="5.3.1" data-path="chapter5.html"><a href="chapter5.html#tensor-products"><i class="fa fa-check"></i><b>5.3.1</b> Tensor products</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="chapter5.html"><a href="chapter5.html#back-to-qubits"><i class="fa fa-check"></i><b>5.4</b> Back to qubits</a></li>
<li class="chapter" data-level="5.5" data-path="chapter5.html"><a href="chapter5.html#separable-or-entangled"><i class="fa fa-check"></i><b>5.5</b> Separable or entangled?</a></li>
<li class="chapter" data-level="5.6" data-path="chapter5.html"><a href="chapter5.html#controlled-not"><i class="fa fa-check"></i><b>5.6</b> Controlled-NOT</a>
<ul>
<li class="chapter" data-level="5.6.1" data-path="chapter5.html"><a href="chapter5.html#the-bell-states-and-the-bell-measurement"><i class="fa fa-check"></i><b>5.6.1</b> The Bell states, and the Bell measurement</a></li>
<li class="chapter" data-level="5.6.2" data-path="chapter5.html"><a href="chapter5.html#quantum-teleportation"><i class="fa fa-check"></i><b>5.6.2</b> Quantum teleportation</a></li>
<li class="chapter" data-level="5.6.3" data-path="chapter5.html"><a href="chapter5.html#thou-shalt-not-clone"><i class="fa fa-check"></i><b>5.6.3</b> Thou shalt not clone</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="chapter5.html"><a href="chapter5.html#other-controlled-gates"><i class="fa fa-check"></i><b>5.7</b> Other controlled gates</a>
<ul>
<li class="chapter" data-level="5.7.1" data-path="chapter5.html"><a href="chapter5.html#controlled-phase"><i class="fa fa-check"></i><b>5.7.1</b> Controlled-phase</a></li>
<li class="chapter" data-level="5.7.2" data-path="chapter5.html"><a href="chapter5.html#controlled-u"><i class="fa fa-check"></i><b>5.7.2</b> Controlled-U</a></li>
<li class="chapter" data-level="5.7.3" data-path="chapter5.html"><a href="chapter5.html#phase-kickback"><i class="fa fa-check"></i><b>5.7.3</b> Phase kickback</a></li>
<li class="chapter" data-level="5.7.4" data-path="chapter5.html"><a href="chapter5.html#universality-revisited"><i class="fa fa-check"></i><b>5.7.4</b> Universality revisited</a></li>
<li class="chapter" data-level="5.7.5" data-path="chapter5.html"><a href="chapter5.html#density-operators-and-the-like"><i class="fa fa-check"></i><b>5.7.5</b> Density operators and the like</a></li>
</ul></li>
<li class="chapter" data-level="5.8" data-path="chapter5.html"><a href="chapter5.html#why-qubits-subsystems-and-entanglement"><i class="fa fa-check"></i><b>5.8</b> Why qubits, subsystems, and entanglement?</a></li>
<li class="chapter" data-level="5.9" data-path="chapter5.html"><a href="chapter5.html#remarks-and-exercises-1"><i class="fa fa-check"></i><b>5.9</b> Remarks and exercises</a>
<ul>
<li class="chapter" data-level="5.9.1" data-path="chapter5.html"><a href="chapter5.html#entangled-or-not"><i class="fa fa-check"></i><b>5.9.1</b> Entangled or not?</a></li>
<li class="chapter" data-level="5.9.2" data-path="chapter5.html"><a href="chapter5.html#section-11"><i class="fa fa-check"></i><b>5.9.2</b> </a></li>
<li class="chapter" data-level="5.9.3" data-path="chapter5.html"><a href="chapter5.html#section-12"><i class="fa fa-check"></i><b>5.9.3</b> </a></li>
<li class="chapter" data-level="5.9.4" data-path="chapter5.html"><a href="chapter5.html#section-13"><i class="fa fa-check"></i><b>5.9.4</b> </a></li>
<li class="chapter" data-level="5.9.5" data-path="chapter5.html"><a href="chapter5.html#arbitrary-controlled-u-on-two-qubits"><i class="fa fa-check"></i><b>5.9.5</b> Arbitrary controlled-<span class="math inline">U</span> on two qubits</a></li>
<li class="chapter" data-level="5.9.6" data-path="chapter5.html"><a href="chapter5.html#entangled-qubits"><i class="fa fa-check"></i><b>5.9.6</b> Entangled qubits</a></li>
<li class="chapter" data-level="5.9.7" data-path="chapter5.html"><a href="chapter5.html#quantum-dense-coding"><i class="fa fa-check"></i><b>5.9.7</b> Quantum dense coding</a></li>
<li class="chapter" data-level="5.9.8" data-path="chapter5.html"><a href="chapter5.html#playing-with-conditional-unitaries"><i class="fa fa-check"></i><b>5.9.8</b> Playing with conditional unitaries</a></li>
</ul></li>
<li class="chapter" data-level="5.10" data-path="chapter5.html"><a href="chapter5.html#appendix-tensor-products-in-components"><i class="fa fa-check"></i><b>5.10</b> Appendix: Tensor products in components</a></li>
<li class="chapter" data-level="5.11" data-path="chapter5.html"><a href="chapter5.html#appendix-the-schmidt-decomposition"><i class="fa fa-check"></i><b>5.11</b> Appendix: The Schmidt decomposition</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="chapter6.html"><a href="chapter6.html"><i class="fa fa-check"></i><b>6</b> Quantum algorithms</a>
<ul>
<li class="chapter" data-level="6.1" data-path="chapter6.html"><a href="chapter6.html#quantum-boolean-function-evaluation"><i class="fa fa-check"></i><b>6.1</b> Quantum Boolean function evaluation</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="chapter6.html"><a href="chapter6.html#example"><i class="fa fa-check"></i><b>6.1.1</b> Example</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="chapter6.html"><a href="chapter6.html#phase-kick-back"><i class="fa fa-check"></i><b>6.2</b> Phase kick-back</a></li>
<li class="chapter" data-level="6.3" data-path="chapter6.html"><a href="chapter6.html#oracles-and-query-complexity"><i class="fa fa-check"></i><b>6.3</b> Oracles and query complexity</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="chapter6.html"><a href="chapter6.html#deutschs-algorithm"><i class="fa fa-check"></i><b>6.3.1</b> Deutsch’s algorithm</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="chapter6.html"><a href="chapter6.html#three-more-quantum-algorithms"><i class="fa fa-check"></i><b>6.4</b> Three more quantum algorithms</a>
<ul>
<li class="chapter" data-level="6.4.1" data-path="chapter6.html"><a href="chapter6.html#the-bernstein-vazirani-algorithm"><i class="fa fa-check"></i><b>6.4.1</b> The Bernstein-Vazirani algorithm</a></li>
<li class="chapter" data-level="6.4.2" data-path="chapter6.html"><a href="chapter6.html#grovers-search-algorithm"><i class="fa fa-check"></i><b>6.4.2</b> Grover’s search algorithm</a></li>
<li class="chapter" data-level="6.4.3" data-path="chapter6.html"><a href="chapter6.html#simons-problem"><i class="fa fa-check"></i><b>6.4.3</b> Simon’s problem</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="chapter6.html"><a href="chapter6.html#remarks-and-exercises-2"><i class="fa fa-check"></i><b>6.5</b> Remarks and exercises</a></li>
</ul></li>
<li class="part"><span><b>II Flowering</b></span></li>
<li class="chapter" data-level="7" data-path="chapter7.html"><a href="chapter7.html"><i class="fa fa-check"></i><b>7</b> Bell’s theorem</a>
<ul>
<li class="chapter" data-level="7.1" data-path="chapter7.html"><a href="chapter7.html#quantum-correlations"><i class="fa fa-check"></i><b>7.1</b> Quantum correlations</a></li>
<li class="chapter" data-level="7.2" data-path="chapter7.html"><a href="chapter7.html#hidden-variables"><i class="fa fa-check"></i><b>7.2</b> Hidden variables</a></li>
<li class="chapter" data-level="7.3" data-path="chapter7.html"><a href="chapter7.html#chsh-inequality"><i class="fa fa-check"></i><b>7.3</b> CHSH inequality</a></li>
<li class="chapter" data-level="7.4" data-path="chapter7.html"><a href="chapter7.html#quantum-correlations-revisited"><i class="fa fa-check"></i><b>7.4</b> Quantum correlations revisited</a></li>
<li class="chapter" data-level="7.5" data-path="chapter7.html"><a href="chapter7.html#tsirelsons-inequality"><i class="fa fa-check"></i><b>7.5</b> Tsirelson’s inequality</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="chapter8.html"><a href="chapter8.html"><i class="fa fa-check"></i><b>8</b> Decoherence, and elements of quantum error correction</a>
<ul>
<li class="chapter" data-level="8.1" data-path="chapter8.html"><a href="chapter8.html#decoherence-simplified"><i class="fa fa-check"></i><b>8.1</b> Decoherence simplified</a></li>
<li class="chapter" data-level="8.2" data-path="chapter8.html"><a href="chapter8.html#decoherence-and-interference"><i class="fa fa-check"></i><b>8.2</b> Decoherence and interference</a></li>
<li class="chapter" data-level="8.3" data-path="chapter8.html"><a href="chapter8.html#evolution-of-density-operators-under-decoherence"><i class="fa fa-check"></i><b>8.3</b> Evolution of density operators under decoherence</a></li>
<li class="chapter" data-level="8.4" data-path="chapter8.html"><a href="chapter8.html#quantum-errors"><i class="fa fa-check"></i><b>8.4</b> Quantum errors</a></li>
<li class="chapter" data-level="8.5" data-path="chapter8.html"><a href="chapter8.html#same-evolution-different-errors"><i class="fa fa-check"></i><b>8.5</b> Same evolution, different errors</a></li>
<li class="chapter" data-level="8.6" data-path="chapter8.html"><a href="chapter8.html#some-errors-can-be-corrected-on-some-states"><i class="fa fa-check"></i><b>8.6</b> Some errors can be corrected on some states</a></li>
<li class="chapter" data-level="8.7" data-path="chapter8.html"><a href="chapter8.html#repetition-codes"><i class="fa fa-check"></i><b>8.7</b> Repetition codes</a></li>
<li class="chapter" data-level="8.8" data-path="chapter8.html"><a href="chapter8.html#quantum-error-correction"><i class="fa fa-check"></i><b>8.8</b> Quantum error correction</a></li>
<li class="chapter" data-level="8.9" data-path="chapter8.html"><a href="chapter8.html#turning-bit-flips-into-phase-flips"><i class="fa fa-check"></i><b>8.9</b> Turning bit-flips into phase-flips</a></li>
<li class="chapter" data-level="8.10" data-path="chapter8.html"><a href="chapter8.html#dealing-with-bit-flip-and-phase-flip-errors"><i class="fa fa-check"></i><b>8.10</b> Dealing with bit-flip and phase-flip errors</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="chapter9.html"><a href="chapter9.html"><i class="fa fa-check"></i><b>9</b> Density matrices</a>
<ul>
<li class="chapter" data-level="9.1" data-path="chapter9.html"><a href="chapter9.html#definitions"><i class="fa fa-check"></i><b>9.1</b> Definitions</a></li>
<li class="chapter" data-level="9.2" data-path="chapter9.html"><a href="chapter9.html#mixtures"><i class="fa fa-check"></i><b>9.2</b> Mixtures</a></li>
<li class="chapter" data-level="9.3" data-path="chapter9.html"><a href="chapter9.html#a-few-instructive-examples-and-some-less-instructive-remarks"><i class="fa fa-check"></i><b>9.3</b> A few instructive examples, and some less instructive remarks</a></li>
<li class="chapter" data-level="9.4" data-path="chapter9.html"><a href="chapter9.html#mixed-states-of-a-qubit-and-the-bloch-sphere"><i class="fa fa-check"></i><b>9.4</b> Mixed states of a qubit, and the Bloch sphere</a></li>
<li class="chapter" data-level="9.5" data-path="chapter9.html"><a href="chapter9.html#subsystems-of-entangled-systems"><i class="fa fa-check"></i><b>9.5</b> Subsystems of entangled systems</a></li>
<li class="chapter" data-level="9.6" data-path="chapter9.html"><a href="chapter9.html#partial-trace-revisited"><i class="fa fa-check"></i><b>9.6</b> Partial trace, revisited</a></li>
<li class="chapter" data-level="9.7" data-path="chapter9.html"><a href="chapter9.html#mixtures-and-subsystems"><i class="fa fa-check"></i><b>9.7</b> Mixtures and subsystems</a></li>
<li class="chapter" data-level="9.8" data-path="chapter9.html"><a href="chapter9.html#partial-trace-yet-again"><i class="fa fa-check"></i><b>9.8</b> Partial trace, yet again</a></li>
<li class="chapter" data-level="9.9" data-path="chapter9.html"><a href="chapter9.html#notes-and-exercises"><i class="fa fa-check"></i><b>9.9</b> Notes and exercises</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="chapter10.html"><a href="chapter10.html"><i class="fa fa-check"></i><b>10</b> Quantum channels (or CP maps)</a></li>
<li class="chapter" data-level="11" data-path="chapter11.html"><a href="chapter11.html"><i class="fa fa-check"></i><b>11</b> Quantum error correction and fault tolerance</a></li>
<li class="chapter" data-level="12" data-path="chapter12.html"><a href="chapter12.html"><i class="fa fa-check"></i><b>12</b> Bonus material</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Lectures on Quantum Information Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="chapter6" class="section level1" number="6">
<h1><span class="header-section-number">Chapter 6</span> Quantum algorithms</h1>
<blockquote>
<p>About quantum interference in disguise: Hadamard, function evaluation, Hadamard.
Also about the early quantum algorithms and how they deal with querying oracles, searching for a needle in a haystack, and estimating periodicity of certain functions.</p>
</blockquote>
<p><strong>!!!TODO!!!</strong></p>
<div id="quantum-boolean-function-evaluation" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> Quantum Boolean function evaluation</h2>
<p>Classical computers essentially evaluate functions: given <span class="math inline">n</span>-bits of input they produce <span class="math inline">m</span>-bits of output that are uniquely determined by the input; that is, they find the value of
<span class="math display">
  f\colon \{0,1\}^n \to \{0,1\}^m
</span>
for a particular specified <span class="math inline">n</span>-bit argument.
A function with an <span class="math inline">m</span>-bit value is equivalent to <span class="math inline">m</span> Boolean functions, each with a one-bit value, so we may just as well say that the basic task performed by a computer is the evaluation of Boolean functions
<span class="math display">
  f\colon \{0,1\}^n \to  \{0,1\}.
</span>
<em>In quantum computation, all elementary operations are reversible</em> (unitary), so we compute Boolean functions in a reversible fashion as
<span class="math display">
  |x\rangle|y\rangle \mapsto |x\rangle|y\oplus f(x)\rangle.
</span></p>
<p>The corresponding circuit diagram (for <span class="math inline">n=3</span>) is shown in Figure <a href="chapter6.html#fig:n-equals-3-circuit-diagram">6.1</a>.</p>

<div class="figure" style="text-align: center"><span id="fig:n-equals-3-circuit-diagram"></span>
<img src="quantum-info_files/figure-html/n-equals-3-circuit-diagram-1.png" alt="Computing some f\colon\{0,1\}^3\to\{0,1\} in a quantum manner." width="672" />
<p class="caption">
Figure 6.1: Computing some <span class="math inline">f\colon\{0,1\}^3\to\{0,1\}</span> in a quantum manner.
</p>
</div>
<p>Here we use two registers: the first one (counting from the top to the bottom of the circuit diagram) stores the arguments <span class="math inline">x</span>, and the second one the values <span class="math inline">f(x)</span>.
More precisely, the value <span class="math inline">f(x)</span> is added bit-wise to the pre-existing binary value <span class="math inline">y</span> of the second register.
We usually set <span class="math inline">y=0</span> to get
<span class="math display">
  |x\rangle|0\rangle \mapsto |x\rangle|f(x)\rangle.
</span></p>
<p>Quantum Boolean function evaluation is a special case of the generalised <span class="math inline">x</span>-controlled-<span class="math inline">U</span> on two registers:
<span class="math display">
  \sum_x |x\rangle\langle x|\otimes U_x
</span>
where <span class="math inline">U_x</span> is either the identity <span class="math inline">\mathbf{1}</span> (when <span class="math inline">f(x)=0</span>) or the bit-flip<a href="#fn81" class="footnote-ref" id="fnref81"><sup>81</sup></a> <span class="math inline">X</span> (when <span class="math inline">f(x)=1</span>).
We may also write this as
<span class="math display">
  \sum_x |x\rangle\langle x|\otimes X^{f(x)}.
</span></p>
<div id="example" class="section level3" number="6.1.1">
<h3><span class="header-section-number">6.1.1</span> Example</h3>
<p>Consider the Boolean function <span class="math inline">f\colon\{0,1\}^2\to\{0,1\}</span> given by
<span class="math display">
  f(x)
  =
  \begin{cases}
    1 &amp;\mbox{if $x=01$,}
  \\0 &amp;\mbox{otherwise.}
  \end{cases}
</span>
The evaluation <span class="math inline">|x\rangle|y\rangle \mapsto |x\rangle|y\oplus f(x)\rangle</span> can be tabulated explicitly as
<span class="math display">
  \begin{array}{cc}
    |00\rangle|0\rangle \mapsto |00\rangle|0\rangle
    &amp; |00\rangle|1\rangle \mapsto |00\rangle|1\rangle
  \\|01\rangle|0\rangle \mapsto |01\rangle|1\rangle
    &amp; |01\rangle|1\rangle \mapsto |01\rangle|0\rangle
  \\|10\rangle|0\rangle \mapsto |10\rangle|0\rangle
    &amp; |10\rangle|1\rangle \mapsto |10\rangle|1\rangle
  \\|11\rangle|0\rangle \mapsto |11\rangle|0\rangle
    &amp; |11\rangle|1\rangle \mapsto |11\rangle|1\rangle
  \end{array}
</span>
and the expression <span class="math inline">\sum_x |x\rangle\langle x|\otimes X^{f(x)}</span> becomes
<span class="math display">
  \begin{aligned}
    &amp;|00\rangle\langle 00|00 \otimes \mathbf{1}
  \\+ &amp;|01\rangle\langle 01|01 \otimes X
  \\+ &amp;|10\rangle\langle 10|10 \otimes \mathbf{1}
  \\+ &amp;|11\rangle\langle 11|11 \otimes \mathbf{1}.
  \end{aligned}
</span>
Finally, the matrix form looks like
<span class="math display">
  \left[
  \,
    \begin{array}{c|c|c|c}
      \begin{matrix}1&amp;0\\0&amp;1\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
    \\\hline
    \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;1\\1&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
    \\\hline
    \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}1&amp;0\\0&amp;1\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
    \\\hline
    \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}0&amp;0\\0&amp;0\end{matrix}
      &amp; \begin{matrix}1&amp;0\\0&amp;1\end{matrix}
    \end{array}
  \,
  \right]
</span>
As you can see, this is a diagonal block matrix: a <span class="math inline">(4\times 4)</span> matrix with <span class="math inline">(2\times 2)</span> matrices as entries.
The rows and the columns of the <span class="math inline">(4\times 4)</span> matrix are labelled by the binary strings <span class="math inline">00, 01, 10, 11</span>, and the <span class="math inline">(2\times 2)</span> matrices on the diagonal represent operations applied to the qubit in the second register.
Here all of them are the identity <span class="math inline">\mathbf{1}</span> except the <span class="math inline">(01, 01)</span> entry, which represents the bit-flip <span class="math inline">X</span>.
This is because <span class="math inline">f(01)=1</span>, and <span class="math inline">f(x)=0</span> for all other binary strings <span class="math inline">x</span>.</p>
</div>
</div>
<div id="phase-kick-back" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Phase kick-back</h2>
<p>What makes the quantum evaluation of Boolean functions really interesting is its action on a superposition of different inputs <span class="math inline">x</span>.
For example,
<span class="math display">
  \sum_{x}|x\rangle|0\rangle
  \longmapsto
  \sum_{x}|x\rangle|f(x)\rangle
</span>
produces <span class="math inline">f(x)</span> for <em>all</em> <span class="math inline">x</span> in a <em>single</em> run (note that we have dropped the normalisation factor).
It is more instructive to see the effect of the function evaluation when the qubit in the second register is prepared in the state <span class="math inline">|-\rangle = \frac{1}{\sqrt 2}(|0\rangle - |1\rangle</span>, since then
<span class="math display">
  \sum_x|x\rangle|-\rangle
  \longmapsto
  \sum_x (-1)^{f(x)}|x\rangle|-\rangle
</span>
(as shown in Figure <a href="chapter6.html#fig:n-equals-3-minus-circuit-diagram">6.2</a>).
Whenever <span class="math inline">f(x)=1</span>, the bit flip <span class="math inline">X</span> is applied to the qubit in the second register.</p>

<div class="figure" style="text-align: center"><span id="fig:n-equals-3-minus-circuit-diagram"></span>
<img src="quantum-info_files/figure-html/n-equals-3-minus-circuit-diagram-1.png" alt="Computing some f\colon\{0,1\}^3\to\{0,1\} with the second-register qubit in state |-\rangle." width="672" />
<p class="caption">
Figure 6.2: Computing some <span class="math inline">f\colon\{0,1\}^3\to\{0,1\}</span> with the second-register qubit in state <span class="math inline">|-\rangle</span>.
</p>
</div>
<p>The reason for defining the state <span class="math inline">|-\rangle</span> as we do is that it is the eigenstate of <span class="math inline">X</span> with eigenvalue <span class="math inline">-1</span>.
So, due the phase kick-back, whenever <span class="math inline">f(x)=1</span>, the phase factor <span class="math inline">-1</span> appears in front of the corresponding term <span class="math inline">|x\rangle</span>.
As you can see, the second register stays in state <span class="math inline">|-\rangle</span> all the way through the computation — it is the first register where things happen.
Let us now see how quantum Boolean function evaluation introduces phase shifts in quantum interference experiments, and how such experiments can be viewed as computations.</p>
</div>
<div id="oracles-and-query-complexity" class="section level2" number="6.3">
<h2><span class="header-section-number">6.3</span> Oracles and query complexity</h2>
<p>The computational power of quantum interference was discovered by counting how many times certain Boolean functions have to be evaluated in order to find the answer to a given problem.
Imagine a “black box” (also called an <strong>oracle</strong>) that computes some fixed Boolean function, but whose inner workings are unknown to us, and a scenario in which one wants to learn about a given property of the Boolean function but has to “pay” (in energy, or in money!) for each use (often referred to as a <strong>query</strong>) of the box.
In such a setting, the objective is to minimise number of queries to the oracle while finding out as much information as possible about the function computed by the oracle.
For this purpose, we ignore everything that happens inside the black box: the Boolean function evaluation counts as just <em>one</em> computational step.</p>
<div id="deutschs-algorithm" class="section level3" number="6.3.1">
<h3><span class="header-section-number">6.3.1</span> Deutsch’s algorithm</h3>
<p>We start, once more, with the simplest quantum interference circuit:</p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-51-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Suppose you can prepare the input, you can read the output, you <em>cannot</em> see the phase shifter, <em>but</em> you are promised that the phase shifter is set to either <span class="math inline">\varphi=0</span> or <span class="math inline">\varphi=\pi</span>.
Can you tell which value <span class="math inline">\varphi</span> has been set to?</p>
<p>Of course you can!</p>
<p>One way of doing it is to set your input to <span class="math inline">|0\rangle</span> and check the output: for <span class="math inline">\varphi=0</span> the output is always <span class="math inline">|0\rangle</span>, and for <span class="math inline">\varphi=\pi</span> it is always <span class="math inline">|1\rangle</span>.
A single run of the interference experiment is sufficient to determine the difference.
The first quantum algorithm, proposed by David Deutsch in 1985, is very much related to this effect, but where the phase setting is determined by the Boolean function evaluation via the phase kick-back.</p>
<div class="scenario">
<p>We are presented with an oracle that computes some unknown function <span class="math inline">f\colon\{0,1\}\to\{0,1\}</span>.
Note that there are only four possibilities for what <span class="math inline">f</span> can be: it could be one of two constant functions (i.e. those where <span class="math inline">f(0)=f(1)</span>), or one of two “balanced” functions (i.e. those where <span class="math inline">f(0)\neq f(1)</span>).</p>
<table>
<thead>
<tr class="header">
<th align="right"></th>
<th align="center"><span class="math inline">f(0)</span></th>
<th align="center"><span class="math inline">f(1)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">constant</td>
<td align="center"><span class="math inline">\begin{matrix}0\\1\end{matrix}</span></td>
<td align="center"><span class="math inline">\begin{matrix}0\\1\end{matrix}</span></td>
</tr>
<tr class="even">
<td align="right">balanced</td>
<td align="center"><span class="math inline">\begin{matrix}0\\1\end{matrix}</span></td>
<td align="center"><span class="math inline">\begin{matrix}1\\0\end{matrix}</span></td>
</tr>
</tbody>
</table>
<p>Our task is to determine, using the fewest queries possible, whether the function computed by the oracle is constant or balanced.</p>
</div>
<p>Note that we are <em>not</em> asked for the particular values <span class="math inline">f(0)</span> and <span class="math inline">f(1)</span>, but <em>only whether the two values are the same or different</em>.
Classical intuition tells us that we have to evaluate both <span class="math inline">f(0)</span> and <span class="math inline">f(1)</span> and compare them, which involves evaluating <span class="math inline">f</span> <em>twice</em>.
But, in the quantum setting, we can solve this problem with a <em>single</em> function evaluation, using the following circuit.</p>
<div class="circuit">
<div class="circuit_title">
<p>(Deutsch’s).</p>
</div>
<p><em>First register: <span class="math inline">1</span> qubit. Second register: <span class="math inline">1</span> qubit.</em></p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-52-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<p>During the function evaluation, the second register “kicks back” the phase factor <span class="math inline">(-1)^{f(x)}</span> in front of <span class="math inline">|x\rangle</span>, but the state of the second register remains unchanged; the first register is modified as follows:
<span class="math display">
  \begin{aligned}
    |0\rangle
    &amp;\overset{H}{\longmapsto}
    |0\rangle+|1\rangle
  \\&amp;\overset{f}{\longmapsto}
    (-1)^{f(0)}|0\rangle + (-1)^{f(1)}|1\rangle
  \\&amp;\quad\equiv
    |0\rangle + (-1)^{f(0)\oplus f(1)}|1\rangle
  \\&amp;\overset{H}{\longmapsto}
    |f(0)\oplus f(1)\rangle.
  \end{aligned}
</span></p>
<p>This evolution can be represented by the circuit diagram</p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-53-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>where the relative phase is <span class="math inline">\varphi = (-1)^{f(0)\oplus f(1)}</span>.
The first qubit ends in state <span class="math inline">|0\rangle</span> if the function <span class="math inline">f</span> is constant, and in state <span class="math inline">|1\rangle</span> if the function is balanced, and the standard measurement distinguishes these two cases with certainty.<a href="#fn82" class="footnote-ref" id="fnref82"><sup>82</sup></a></p>
<p>Deutsch’s result laid the foundation for the new field of quantum computation, and was followed by several other quantum algorithms for various problems.
They all seem to rest on the same generic sequence: a Hadamard transform, followed by a function evaluation, followed by another Hadamard (or Fourier) transform.<a href="#fn83" class="footnote-ref" id="fnref83"><sup>83</sup></a>
As we shall see in a moment, in some cases (such as in Grover’s search algorithm) this sequence is repeated several times.
Let me now take you through the three early quantum algorithms, each one offering a higher-order speed-up when compared to their classical analogues than the last.</p>
</div>
</div>
<div id="three-more-quantum-algorithms" class="section level2" number="6.4">
<h2><span class="header-section-number">6.4</span> Three more quantum algorithms</h2>
<p>Along with Deutsch’s algorithm, there are three more fundamental quantum algorithms that we will study here.
Each one was designed to solve a different specific problem, but they all share some similarity: this omnipresent sequence of Hadamard, function evaluation, Hadamard.</p>
<div id="the-bernstein-vazirani-algorithm" class="section level3" number="6.4.1">
<h3><span class="header-section-number">6.4.1</span> The Bernstein-Vazirani algorithm</h3>
<div class="scenario">
<p>We are presented with an oracle that computes some unknown function <span class="math inline">f\colon\{0,1\}^n\to\{0,1\}</span>, but we are promised that <span class="math inline">f</span> is of the form
<span class="math display">
  f(x) = a\cdot x
  \equiv (a_1\cdot x_1) \oplus \ldots \oplus (a_n\cdot x_n)
</span>
for some fixed <span class="math inline">a\in\{0,1\}^n</span>.</p>
<p>Our task is to determine, using the fewest queries possible, the value of the <span class="math inline">n</span>-bit string <span class="math inline">a</span>.</p>
</div>
<p>It’s quite easy to see how to do this classically: if we input the value <span class="math inline">x=00\ldots010\ldots0</span>, with the <span class="math inline">1</span> in the <span class="math inline">m</span>-th bit, then <span class="math inline">f(x)</span> is simply the <span class="math inline">m</span>-th bit of <span class="math inline">a</span>; after <span class="math inline">n</span> such calls, we can evaluate every bit value.
It is also clear that there cannot exist a better classical algorithm: each call to the oracle teaches us exactly one bit of information, and since we must learn <span class="math inline">n</span> bits, we must query it <span class="math inline">n</span> times.</p>
<p>In contrast, by running the circuit below, it is possible to determine the value of <span class="math inline">a</span> with a <em>single</em> (!) call to the oracle.</p>
<div class="circuit">
<div class="circuit_title">
<p>(Bernstein-Vazirani).</p>
</div>
<p><em>First register: <span class="math inline">n</span> qubits. Second register: <span class="math inline">1</span> qubit.</em></p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-54-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<p>N.B. The “<span class="math inline">\ldots</span>” in the circuit means “there are more wires here but they are identical (apart from the numbering) to the ones above”.
You might also see other notation to denote this, such as</p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-55-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>or even simply</p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-56-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Stepping through the execution of the circuit (and ignoring the second register, which remains in state <span class="math inline">|-\rangle</span> throughout), we obtain
<span class="math display">
  \begin{aligned}
    |0\rangle
    &amp;\overset{H}{\longmapsto}
    \left(\frac{1}{\sqrt2}\right)^n \sum_{x\in\{0,1\}^n} |x\rangle
  \\&amp;\overset{f}{\longmapsto}
    \left(\frac{1}{\sqrt2}\right)^n \sum_{x\in\{0,1\}^n} (-1)^{a\cdot x}|x\rangle
  \\&amp;\overset{H}{\longmapsto}
    \left(\frac{1}{\sqrt2}\right)^n \sum_{x\in\{0,1\}^n}
    \left[
      (-1)^{a\cdot x} \left(\frac{1}{\sqrt2}\right)^n
      \sum_{y\in\{0,1\}^n} (-1)^{y\cdot x} |y\rangle
    \right]
  \\&amp;\quad= \left(\frac12\right)^n \sum_{y\in\{0,1\}^n}
    \left[
      \sum_{x\in\{0,1\}^n} (-1)^{(a\oplus y)\cdot x}
    \right]
    |y\rangle
  \\&amp;\quad=|a\rangle
  \end{aligned}
</span>
where we write the second Hadamard transform as
<span class="math display">
  |x\rangle
  \mapsto
  \left(\frac{1}{\sqrt2}\right)^n \sum_{y\in\{0,1\}^n} (-1)^{y\cdot x}|y\rangle
</span>
and where we have used the fact (which you should prove!) that, for any <span class="math inline">y\in\{0,1\}^n</span>,
<span class="math display">
  \sum_{x\in\{0,1\}^n} (-1)^{x\cdot y}
  =
  \begin{cases}
    0 &amp;\mbox{if $y\neq0$}
  \\2^n &amp;\mbox{if $y=0$}
  \end{cases}
</span></p>
<p>This lets us write<a href="#fn84" class="footnote-ref" id="fnref84"><sup>84</sup></a>
<span class="math display">
  \sum_{x\in\{0,1\}^n} (-1)^{(a\oplus y)\cdot x}
  =
  \begin{cases}
    0 &amp;\mbox{if $y\neq a$}
  \\2^n &amp;\mbox{if $y=a$.}
  \end{cases}
</span>
If you take the sum over <span class="math inline">x</span>, then all the terms always cancel out <em>unless</em> <span class="math inline">a\oplus y = 00\ldots0</span>, i.e. <em>unless <span class="math inline">y=a</span></em>.
Thus the standard bit-by-bit measurement of the first register gives the value of <span class="math inline">a</span> and solves the problem with a single call to the oracle.</p>
<p>Note that the algorithm follows the same pattern as Deutsch’s algorithm: Hadamard, function evaluation, Hadamard, i.e. a generic quantum interference pattern.</p>
</div>
<div id="grovers-search-algorithm" class="section level3" number="6.4.2">
<h3><span class="header-section-number">6.4.2</span> Grover’s search algorithm</h3>
<p>The next algorithm we will study aims to solve the problem of searching for a specific item in an <em>unsorted</em> database.
Think about an old-fashioned phone book: the entries are typically sorted alphabetically, by the name of the person that you want to find.
However, what if you were in the opposite situation: you had a phone number and wanted to find the corresponding person’s name?
The phone book is not sorted in that way, and to find the number (and hence name) with, say, 50% probability, you would need to search through, on average, 50% of the entries.
In a large phone book, this would take a long time.</p>
<p>While this might seem like a rather contrived problem (a computer database should always maintain an index on any searchable field), many problems in computer science can be cast in this form, i.e. that of an <strong>unstructured search</strong>.</p>
<div class="scenario">
<p>We are presented with an oracle that computes some unknown function <span class="math inline">f\colon\{0,1\}^n\to\{0,1\}</span>.</p>
<p>Our task is to find, using the fewest queries possible, an input <span class="math inline">x\in\{0,1\}^n</span> such that <span class="math inline">f(x)=1</span>.</p>
</div>
<p>Suppose that we know that, amongst the <span class="math inline">N=2^n</span> binary strings, there are <span class="math inline">M</span> which are “tagged”, with <span class="math inline">N\gg M</span>.
<strong>!!!TODO!!! explain what we mean by “tagged”</strong>
There is no structure in the database, and so any classical search requires around <span class="math inline">N/M</span> steps, i.e. the function <span class="math inline">f</span> must be evaluated roughly <span class="math inline">N/M</span> times.</p>
<p>In contrast, there is a quantum search algorithm, implemented by the circuit below, that was proposed in 1996 by Lov Grover, and which requires only roughly <span class="math inline">\sqrt{N/M}</span> steps.</p>
<div class="circuit">
<div class="circuit_title">
<p>(Grover’s search).</p>
</div>
<p><em>First register: <span class="math inline">n</span> qubits. Second register: <span class="math inline">1</span> qubit.</em></p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-57-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>where <span class="math inline">f_0</span> tags the binary string of <span class="math inline">n</span> zeros: <span class="math inline">f_0(x)=1</span> if <span class="math inline">x=00\ldots0</span>, and <span class="math inline">f_0(x)=0</span> otherwise.</p>
</div>
<p>We can recognise the typical Hadamard, function evaluation, Hadamard sequence, and we can see that the second register (the bottom qubit, in state <span class="math inline">|-\rangle</span>) plays an auxiliary role: the real action takes place in the first register.
However, unlike the previous algorithms, a single call to the oracle does not do very much, and we have to build up the quantum interference in the first register through repeated calls to the oracle (without any intermediate measurements!).</p>
<p>Here, the basic step is the <strong>Grover iteration operator <span class="math inline">G</span></strong>, which is the boxed part of the circuit that we repeat over and over.
After <span class="math inline">O(2^{n/2})</span> applications of <span class="math inline">G</span>, we measure the first register bit-by-bit and obtain the value of <span class="math inline">|z\rangle</span>, which is such that, <em>with “high” probability</em>, <span class="math inline">f(z)=1</span>.
In order to actually <em>see</em> how this algorithm works, and to justify our claim that it gives what we are searching for “with high probability”, we can take a more geometric approach.</p>
<p>First, we define two orthonormal vectors in the Hilbert space of the first register:<a href="#fn85" class="footnote-ref" id="fnref85"><sup>85</sup></a>
<span class="math display">
  \begin{aligned}
    |a\rangle
    &amp;= \frac{1}{\sqrt{N-M}} \sum_{x\in f^{-1}(0)} \!\!\!\!|x\rangle
  \\|b\rangle
    &amp;= \frac{1}{\sqrt{M}} \sum_{x\in f^{-1}(1)} \!\!\!\!|x\rangle
  \end{aligned}
</span>
where <span class="math inline">f^{-1}(i) = \{x\in\{0,1\}^n \mid f(x)=i\}</span>.
These two vectors span a two-dimensional subspace in which the search will take place.</p>
<p>This subspace contains the equally-weighted superposition <span class="math inline">|s\rangle</span> of all binary strings of length <span class="math inline">n</span>:<a href="#fn86" class="footnote-ref" id="fnref86"><sup>86</sup></a>
<span class="math display">
  \begin{aligned}
    |s\rangle
    &amp;= \frac{1}{\sqrt{N}} \sum_x|x\rangle
  \\&amp;= \sqrt{\frac{N-M}{N}}|a\rangle + \sqrt{\frac{M}{N}}|b\rangle
  \\&amp;= (\cos\alpha)|a\rangle + (\sin\alpha)|b\rangle
  \end{aligned}
</span>
where we have parametrised <span class="math inline">\sqrt{\frac{N-M}{N}}</span> as <span class="math inline">\cos\alpha</span>, and <span class="math inline">\sqrt{\frac{M}{N}}</span> as <span class="math inline">\sin\alpha</span>, with <span class="math inline">\alpha\approx\sqrt{\frac{M}{N}}</span>, since <span class="math inline">N\gg M</span>.</p>
<p>The state <span class="math inline">|s\rangle</span> is our starting input for our sequence of Grover iterations, and we will show that, applying <span class="math inline">G</span>, when restricting to the plane spanned by <span class="math inline">|a\rangle</span> and <span class="math inline">|b\rangle</span>, amounts to applying a rotation by angle <span class="math inline">2\alpha</span>.
Grover’s search algorithm can then be understood as a sequence of rotations which take the input state <span class="math inline">|s\rangle</span> towards the target state <span class="math inline">|b\rangle</span>.</p>
<p>To see this, note that the oracle induces the unitary transformation
<span class="math display">
  f\colon |x\rangle \mapsto (-1)^{f(x)}|x\rangle
</span>
which we shall write as <span class="math inline">I_a = 2|a\rangle\langle a|-\mathbf{1}</span>, and interpret as a reflection through the <span class="math inline">|a\rangle</span>-axis.
In particular, evaluation of <span class="math inline">f_0</span> can be written as <span class="math inline">2|0\rangle\langle 0|-\mathbf{1}</span>, and thus thought of as a reflection through the <span class="math inline">|0\rangle</span>-axis.
If we sandwich <span class="math inline">f_0</span> in between two Hadamards then we obtain <span class="math inline">I_s = 2|s\rangle\langle s|-\mathbf{1}</span>, which is reflection through the <span class="math inline">|s\rangle</span>-axis.
The Grover iteration operator <span class="math inline">G</span> is the composition
<span class="math display">
  G = I_s I_a.
</span>
Note also that <span class="math inline">I_a = 2|a\rangle\langle a|-\mathbf{1}= \mathbf{1}-2|b\rangle\langle b|</span>.</p>
<p>Now recall the purely geometric fact that (working in <span class="math inline">2</span>-dimensional Euclidean space), if we have two intersecting lines <span class="math inline">L_1</span> and <span class="math inline">L_2</span>, meeting with angle <span class="math inline">\theta</span>, then reflecting an object through <span class="math inline">L_1</span> and then reflecting the resulting image through <span class="math inline">L_2</span> is the same as simply rotating the original object around the point of intersection <span class="math inline">L_1\cap L_2</span> by <span class="math inline">2\theta</span>.</p>
<p>The angle between <span class="math inline">|a\rangle</span> and <span class="math inline">|s\rangle</span> is <span class="math inline">\alpha</span>, and so, each time <span class="math inline">G</span> is applied, the vector is rotated (around the origin) by <span class="math inline">2\alpha</span> towards the <span class="math inline">|b\rangle</span>-axis.
We just have to choose the right number <span class="math inline">r</span> of steps such that we end up as close to the <span class="math inline">|b\rangle</span>-axis as possible.
The state <span class="math inline">|s\rangle</span> starts at angle <span class="math inline">\alpha</span> to <span class="math inline">|a\rangle</span>, and we should perform our final (and only) measurement when this angle is <span class="math inline">\pi/2</span>, i.e. when <span class="math inline">(2r+1)\alpha = \pi/2</span>, which gives
<span class="math display">
  r \approx \frac{\pi}{4}\sqrt{\frac{N}{M}}.
</span></p>
<div class="figure" style="text-align: center"><span id="fig:grover-search-geometrically"></span>
<img src="quantum-info_files/figure-html/grover-search-geometrically-1.png" alt="Understanding the Grover search algorithm geometrically." width="576" />
<p class="caption">
Figure 6.3: Understanding the Grover search algorithm geometrically.
</p>
</div>
<p>So the quantum algorithm searches an unsorted list of <span class="math inline">N</span> items in roughly <span class="math inline">\sqrt{N}</span> steps: it offers a <em>quadratic</em> speed-up when compared to classical search, which can be of immense practical importance.
For example, cracking some of the popular ciphers, such as AES (Advanced Encryption Standard), essentially requires a search among <em>many</em> binary strings (called <strong>keys</strong>).
If these can be checked at a rate of, say, one million keys per second, then a classical computer would need over a thousand years to find the correct key, while a quantum computer using Grover’s algorithm would find it in less than four minutes.</p>
</div>
<div id="simons-problem" class="section level3" number="6.4.3">
<h3><span class="header-section-number">6.4.3</span> Simon’s problem</h3>
<p>Here we will see the simplest quantum algorithm that shows an exponential speed-up compared to the best classical algorithm.</p>
<div class="scenario">
<p>We are presented with an oracle that computes some unknown function <span class="math inline">f\colon\{0,1\}^n\to\{0,1\}^n</span>, but we are promised that <span class="math inline">f</span> satisfies<a href="#fn87" class="footnote-ref" id="fnref87"><sup>87</sup></a>
<span class="math display">
  f(x) = f(x\oplus s)
</span>
for some fixed <span class="math inline">s\in\{0,1\}^n</span>, which we call the <strong>period</strong> of <span class="math inline">f</span>.</p>
<p>Our task is to determine, using the fewest queries possible, the value of the <span class="math inline">n</span>-bit string <span class="math inline">s</span>.</p>
</div>
<p>Classically, this problem is exponentially hard.
We will not go through a detailed proof of this fact, but the intuition is reasonably simple: since there is no structure in the function <span class="math inline">f</span> that would help us find its period <span class="math inline">s</span>, the best we can do is evaluate <span class="math inline">f</span> on random inputs and hope that we find some distinct <span class="math inline">x</span> and <span class="math inline">x&#39;</span> such that <span class="math inline">f(x)=f(x&#39;)</span>, and then we know that <span class="math inline">s=x\oplus y</span>.
After having made <span class="math inline">m</span> queries to the oracle, we have a list of <span class="math inline">m</span> values of the tuple <span class="math inline">(x,f(x))</span>; there are <span class="math inline">m(m-1)/2</span> possible pairs which could match within this list, and the probability that a randomly chosen pair match is <span class="math inline">1/2^{n-1}</span>.
This means that the probability of there being at least one matching pair within the list of <span class="math inline">m</span> tuples is less than <span class="math inline">m^2/2^n</span>.
Clearly, the chance of finding a matching pair is negligible if the oracle is queried on fewer than <span class="math inline">\sqrt{2^n}</span> inputs.</p>
<p>The quantum case, on the other hand, gives a result with high probability within a <em>linear</em> number of steps.
The circuit that solves this problem, shown below, has a familiar Hadamard–function–Hadamard structure, but the second register has been expanded to <span class="math inline">n</span> qubits.</p>
<div class="circuit">
<div class="circuit_title">
<p>(Simon’s problem).</p>
</div>
<p><em>First register: <span class="math inline">n</span> qubits. Second register: <span class="math inline">n</span> qubits.</em></p>
<p><img src="quantum-info_files/figure-html/unnamed-chunk-58-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<p>Let’s follow the evolution of the two registers in this circuit.
We start off by preparing the equally-weighted superposition of all <span class="math inline">n</span>-bit strings, and then query the oracle:
<span class="math display">
  \begin{aligned}
    |0^n\rangle|0^n\rangle
    &amp;\longmapsto
    \frac{1}{\sqrt{2^n}} \sum_x |x\rangle|0^n\rangle
  \\&amp;\longmapsto
    \frac{1}{\sqrt{2^n}} \sum_x |x\rangle|f(x)\rangle.
  \end{aligned}
</span>
The second Hadamard transform on the first register then yields the final output state:
</p>
<p>Now, if we measure the second register <em>before</em> applying the second Hadamard transform to the first, we obtain one of the <span class="math inline">2^{n-1}</span> possible values of <span class="math inline">f(x)</span>, each equally likely.<a href="#fn88" class="footnote-ref" id="fnref88"><sup>88</sup></a>
<strong>!!!TODO!!! have I understood this correctly?</strong></p>
<p>Suppose that the outcome of the measurement is <span class="math inline">f(a)</span>.
Given that both <span class="math inline">a</span> and <span class="math inline">a\oplus s</span> are mapped to <span class="math inline">f(a)</span> by <span class="math inline">f</span>, the first register then collapses to the state
<span class="math display">
  \frac{1}{\sqrt{2}}\big( |a\rangle + |a\oplus s\rangle \big).
</span></p>
<p>The subsequent Hadamard transform on the first register then gives us the final state<a href="#fn89" class="footnote-ref" id="fnref89"><sup>89</sup></a>
<span class="math display">
  \frac{1}{\sqrt{2^{n+1}}} \sum_y (-1)^{a\cdot y}
    \Big( 1 + (-1)^{s\cdot y} \Big) |y\rangle|f(a)\rangle
  =
  \frac{1}{\sqrt{2^{n-1}}} \sum_{y\in s^\perp}
    (-1)^{a\cdot y} |y\rangle|f(a)\rangle
</span>
where we have used the fact that <span class="math inline">(a\oplus s)\cdot y = (a\cdot y)\oplus(s\cdot y)</span>, and that <span class="math inline">1+(-1)^{s\cdot y}</span> can have only two values: either <span class="math inline">2</span> (when <span class="math inline">s\cdot y = 0</span>), or <span class="math inline">0</span> (when <span class="math inline">s\cdot y = 1</span>).
Now we measure the first register: the outcome is selected at random from all possible values of <span class="math inline">y</span> such that <span class="math inline">a\cdot y = 0</span>, each occurring with probability <span class="math inline">1/(2^{n-1})</span>.</p>
<p>In fact, we do not have to measure the second register at all: it was a mathematical shortcut, simply taken for pedagogical purposes.
Instead of collapsing the state to just one term in a superposition, we can express Equation <a href="#eq:final-first-register-simon">(<strong>??</strong>)</a> as<a href="#fn90" class="footnote-ref" id="fnref90"><sup>90</sup></a>
<span class="math display">
  \frac{1}{2^n} \sum_{y,f(a)}
    \Big( (-1)^{a\cdot y} + (-1)^{(a\oplus s)\cdot y} \Big) |y\rangle|f(a)\rangle
  =
  \frac{1}{2^n} \sum_{y,f(a)} (-1)^{a\cdot y}
    \Big( 1 + (-1)^{s\cdot y} \Big) |y\rangle|f(a)\rangle
</span>
where the summation over <span class="math inline">f(a)</span> means summing over all binary strings in the image of <span class="math inline">f</span>.</p>
<p>The output of the algorithm is then
<span class="math display">
  \frac{1}{2^{n-1}} \sum_{y\in s^\perp} |y\rangle
    \sum_{f(a)} (-1)^{a\cdot y} |f(a)\rangle
</span>
and, again, the measurement outcome is selected at random from all possible values of <span class="math inline">y</span> such that <span class="math inline">s\cdot y=0</span>.</p>
<p>We are not quite done yet: we cannot infer <span class="math inline">s</span> from a <em>single</em> output <span class="math inline">y</span>.
However, once we have found <span class="math inline">n</span> linearly independent<a href="#fn91" class="footnote-ref" id="fnref91"><sup>91</sup></a> strings <span class="math inline">y_1,y_2,\ldots,y_n</span>, we can solve the <span class="math inline">n</span> equations
<span class="math display">
  \begin{aligned}
    s\cdot y_1 &amp;= 0
  \\s\cdot y_2 &amp;= 0
  \\&amp;\,\,\,\vdots
  \\s\cdot y_n &amp;= 0
  \end{aligned}
</span>
to determine a unique value of <span class="math inline">s</span>.</p>
<p>So we run this algorithm repeatedly, each time obtaining another value of <span class="math inline">y</span> that satisfies <span class="math inline">s\cdot y = 0</span>.
Every time we find some new value of <span class="math inline">y</span> that is linearly independent of all previous ones, we can discard half the potential candidates for <span class="math inline">s</span>.
The probability that <span class="math inline">y_1,\ldots,y_n</span> are linearly independent is
</p>
<p>Indeed, suppose that we have <span class="math inline">k</span> linearly independent binary strings <span class="math inline">y_1,\ldots,y_k</span>.
Then these strings span a subspace of size <span class="math inline">2^k</span>, consisting of all binary strings of the form <span class="math inline">\bigoplus_{i=1}^k b_i y_i</span>, where <span class="math inline">b_1,\ldots,b_k\in\{0,1\}</span>.
Now suppose we obtain some <span class="math inline">y_{k+1}</span>.
It will be linearly independent from the <span class="math inline">y_1,\ldots,y_k</span> if and only if it lies <em>outside</em> the subspace spanned by the <span class="math inline">y_1,\ldots,y_k</span>, which occurs with probability <span class="math inline">1-(2^k)/(2^n)</span>.
We can bound Equation <a href="#eq:probability-linearly-independent">(<strong>??</strong>)</a> from below:<a href="#fn92" class="footnote-ref" id="fnref92"><sup>92</sup></a>
<span class="math display">
  \left[
    1 -
    \left(
      \frac{1}{2^n} + \frac{1}{2^{n-1}} + \ldots + \frac14
    \right)
  \right]
  \cdot \frac12
  \geqslant\frac14.
</span></p>
<p>We conclude that we can determine <span class="math inline">s</span> with some constant probability of error after repeating the algorithm <span class="math inline">O(n)</span> times.
The exponential separation that this algorithm demonstrates between quantum and classical highlights the vast potential of a quantum computer to speed up function evaluation.</p>

<div class="figure" style="text-align: center"><span id="fig:simons-diagramatically"></span>
<img src="quantum-info_files/figure-html/simons-diagramatically-1.png" alt="Picture all possible binary strings as dots, but with the string s denoted by a star. Every linearly independent y_{k+1} lets us “zoom in” twice as close towards s." width="576" />
<p class="caption">
Figure 6.4: Picture all possible binary strings as dots, but with the string <span class="math inline">s</span> denoted by a star. Every linearly independent <span class="math inline">y_{k+1}</span> lets us “zoom in” twice as close towards <span class="math inline">s</span>.
</p>
</div>
</div>
</div>
<div id="remarks-and-exercises-2" class="section level2" number="6.5">
<h2><span class="header-section-number">6.5</span> Remarks and exercises</h2>
<ol style="list-style-type: decimal">
<li>Consider the Boolean function <span class="math inline">f\colon\{0,1\}^n\to\{0,1\}</span> defined by <span class="math inline">f(x) = a\cdot x</span> for some fixed <span class="math inline">a\in\{0,1\}^n</span>.
Exactly one half of the binary strings <span class="math inline">x\in\{0,1\}^n</span> give <span class="math inline">f(x)=0</span>, and the other half give <span class="math inline">f(x)=1</span>.</li>
<li><strong>!!!TODO!!! implementing reflections</strong></li>
<li><strong>!!!TODO!!! optimality of Grover</strong></li>
</ol>

</div>
</div>



<div class="footnotes">
<hr />
<ol start="81">
<li id="fn81"><p>Do not confuse the capital <span class="math inline">X</span>, which is the Pauli flip operator <span class="math inline">\sigma_x</span>, with the small <span class="math inline">x</span>, which is a binary string stored in the first register and the argument of our Boolean function <span class="math inline">f</span>.<a href="chapter6.html#fnref81" class="footnote-back">↩︎</a></p></li>
<li id="fn82"><p>The original Deutsch algorithm provides the correct answer with probability 50%. Here we have presented a modified/improved version.<a href="chapter6.html#fnref82" class="footnote-back">↩︎</a></p></li>
<li id="fn83"><p>The Hadamard transform is a special case of the Fourier transform over the group <span class="math inline">\mathbb{Z}_2^n</span>.<a href="chapter6.html#fnref83" class="footnote-back">↩︎</a></p></li>
<li id="fn84"><p>Even if you don’t immediately see how this sum works for <span class="math inline">z\neq a</span> (writing <span class="math inline">|z\rangle</span> to mean the output), you can first calculate the probability that the output is <span class="math inline">z=a</span>. In this case it is easy to see that the sum is <span class="math inline">2^n</span>, and that in the final state <span class="math inline">\sum_z\alpha_z|z\rangle</span> the term <span class="math inline">z=a</span> has amplitude <span class="math inline">1</span>. Thus, by normalisation, all the other terms must be equal to <span class="math inline">0</span>.<a href="chapter6.html#fnref84" class="footnote-back">↩︎</a></p></li>
<li id="fn85"><p>In fact, we shall completely ignore the second register from now on.<a href="chapter6.html#fnref85" class="footnote-back">↩︎</a></p></li>
<li id="fn86"><p>We often omit from our notation the fact that the sum is over all , leaving it (hopefully) implicitly understood from the context.<a href="chapter6.html#fnref86" class="footnote-back">↩︎</a></p></li>
<li id="fn87"><p>This is equivalent to saying that <span class="math inline">f</span> is <strong>two-to-one</strong>: for any <span class="math inline">y\in\{0,1\}^n</span> such that there exists some <span class="math inline">x\in\{0,1\}^n</span> with <span class="math inline">f(x)=y</span>, there exists exactly one other <span class="math inline">x&#39;\neq x</span> such that <span class="math inline">f(x&#39;)=y</span> as well.<a href="chapter6.html#fnref87" class="footnote-back">↩︎</a></p></li>
<li id="fn88"><p>As we shall see in a moment, the actual measurement on the second register is not actually necessary.<a href="chapter6.html#fnref88" class="footnote-back">↩︎</a></p></li>
<li id="fn89"><p>We write <span class="math inline">s^\perp</span> to mean the set of all <span class="math inline">y\in\{0,1\}^n</span> such that <span class="math inline">y\cdot s=0</span>.<a href="chapter6.html#fnref89" class="footnote-back">↩︎</a></p></li>
<li id="fn90"><p>Recall that the image of <span class="math inline">f</span> is the set of all <span class="math inline">z\in\{0,1\}^n</span> such that there exists some <span class="math inline">x\in\{0,1\}^n</span> satisfying <span class="math inline">f(x)=z</span>.<a href="chapter6.html#fnref90" class="footnote-back">↩︎</a></p></li>
<li id="fn91"><p>Here, <strong>linearly independent</strong> means that no string in the set <span class="math inline">\{y_1,\ldots,y_n\}</span> can be expressed as the bitwise sum of some other strings in this set.<a href="chapter6.html#fnref91" class="footnote-back">↩︎</a></p></li>
<li id="fn92"><p>Use the inequality <span class="math display">\begin{aligned}(1-x)(1-y)&amp;= 1 - x - y - xy\\&amp;\geqslant 1 - (x+y)\end{aligned}</span> which holds for any <span class="math inline">x,y\in(0,1)</span>.<a href="chapter6.html#fnref92" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
<script type="text/javascript" src="../sidenotes.js"></script>
<script type="text/javascript" src="../MathJax2KaTeX.js"></script>
            </section>

          </div>
        </div>
      </div>
<a href="chapter5.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="chapter7.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": false,
"twitter": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": {}
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": "https://github.com/thosgood/quantum-info/blob/master/06-algorithms.Rmd",
"text": null
},
"download": ["quantum-info.pdf"],
"toc": {
"collapse": "section"
},
"info": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
